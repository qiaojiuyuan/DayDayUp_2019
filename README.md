# DayDayUp_2019
2019年学习工作历程记录

---
## 2019年1月7日
1. 元旦请了三天假，连上了周末两天，休了一个小长假，本来很开心可以多看看女儿，没想到我发烧了，然后又传染给了女儿，女儿直接住院了，我也不能离她太近，
怕再传染给她。我昨天坐火车走了，她还没有出院，希望今天晚上不发烧明天可以出院。
2. 今年形式很严峻，裁员的公司很多，一个岗位有很多人竞争，必须要抓紧时间学习了，没有紧迫感最后都是要被淘汰的，尤其是程序员这行。最近准备整理下学习计划，
3. 今天把运营平台项目中所有的中文字符转成翻译好的英文了
4. 感冒还没好利索，头疼

---
## 2019年1月8日
1. 修改运营平台海外版翻译错误
2. 调研海外版地图，目前谷歌和腾讯均要收费，明天看看百度地图
3. 开发通过点击地图添加圆型空域圆心
4. 开发多边形空域点击地图添加点
5. 开发线形空域点击地图添加点
6. 开发点按钮显示和隐藏逻辑

---
## 2019年1月9日
1. 添加空域点列表可滑动到当前下标
2. 添加提交按钮

---
## 2019年1月10日
1. 添加空域点图片
2. 修改线形空域添加和删除点逻辑
3. 最近状态很差，干什么都干不进去，想学习看会pdf就看不进去了，很焦虑。昨天领导找我们组的每个人都谈话了，我感觉我们组有点危险....不知道最近会有怎样
的变化
4. 添加空域退出判空拦截逻辑

---
## 2019年1月11日
1. 心态很差，需要调整。还好姑娘今天出院了，终于都治好了，下次我再得病啥的可得离远点，要不全家人跟着一起遭罪。
2. 首页的UI逻辑和接口了解了下，下周准备做这块
3. 算法的大O表示法看了一点

---
## 2019年1月14日
1. 有可能被裁员，要开始看看面试题了...会认真的考虑下要不要转到西安
2. 中午去健身了

---
## 2019年1月15日
1. 看了一下数据结构和算法的知识，复习了一下数组、二分查找、跳表、快速排序、归并排序
2. 开发首页接口自动请求逻辑，和一些生命周期关闭接口自动请求逻辑
3. 开发首页网络状态监听广播，目前在注册和反注册方面还有问题，要找到一个比较好的注册和反注册的调用节点
4. 今天组里的同事进行了投票，选出组里贡献最多的人，没想到我会排在第一位，我以为我是后来的，跟大家都不熟悉，基本没什么人会投我，
结果让我比较意外，感谢大家，我是幸运的，要继续努力，虽然不知道年后我们组结果会怎样，但自己不能放弃，只有不断努力，才会更幸运。
也要给女儿做个榜样，要是连我都放弃了，家就完了

---
## 2019年1月16日
1. 中午健身了，工作变动的事看看年后怎么弄吧，尽量走异动，如果这次我再离开京东估计这辈子基本上就进不来了
2. 开发提交空域逻辑，接口目前有问题
3. 开发提交判空逻辑
4. 学习了LinkedHashMap原理，但还有点不太理解，明天再看一次

---
## 2019年1月17日
1. 开发首页搜索无人机逻辑
2. 修改搜索界面数据解析错误问题
3. 把LinkedHashMap原理重新看了一次，理解了其中原理
4. 同事说他有可能会把北京房子卖了去苏州，感觉也不错，北京的生活确实太累，花300万只能买个又小又老的房子，但去苏州就不一样了，生活
质量能提高很多。我们普通的打工者，目前真是没有办法在北京立足，很多人都跟孩子异地，只有放假的时候才能看看孩子，感觉这样活着很难受。
我们努力只是想活的好点，但发现，你怎么努力也就那样，看不到头，只是存款多了些，那又怎么样呢，省吃俭用住着一个不足20平米的卧室，北京的
房子依然买不起，孩子也没办法来到身边。
人生就那么几年，活着到底是为了什么，总是说为了下一代，但我们自己呢，当前的生活我们选择负重前行，这没有错，也是应该做的，但要看牺牲的代价是
什么，更多的人牺牲的是自己的生活时间和健康，最后带来的是什么，如果身体健康是最好的，一但生病就什么都没了。这是一种不健康的生活状态，但这恰恰
是目前大多数人的生活方式。其实我们不想这样，只是没办法，只能扛着。

---
## 2019年1月18日
1. 开发首页搜索无人机逻辑，这块逻辑和界面今天找产品确认了下，重新做了
2. 哈希算法的应该看了下

---
## 2019年1月21日
1. 开发首页搜索无人机逻辑
2. 开发首页无人机列表逻辑
3. 开发无人机列表选中逻辑
4. 今天看了一下面试题，看了下热修复原理
5. 开发圆型空域高度和备降点逻辑，还差提交逻辑没写，完成度80%

---
## 2019年1月22日
1. 开发圆型空域高度和备降点逻辑
2. 修改提交空域崩溃Bug
3. 修改多边形空域点下标计算错误
4. 开发多边型空域高度和备降点逻辑
5. 今天发了春节礼包，感觉还不错
6. 最近一直在健身，希望年后了依然可以坚持...不过这个取决于工作，希望年后有好消息，今天波哥也跟我说了一些，还是有一点希望的

---
## 2019年1月23日
1. 添加首页电子围栏接口
2. 添加首页计划和申请计划跳转

---
## 2019年1月24日
1. 开发圆形空域编辑逻辑
2. 修改提交圆形空域缺少备降点bug
3. 开发空域编辑多边形逻辑
4. 今天开会，说了下年度绩效低会被裁员的事情，感觉很压抑，之前总听说经济不好公司会裁员，没想到会发生到自己身上，希望明年好运吧。
今天本来中午要去游泳，结果因为这个事没去上，看看明天能不能去，不希望再有坏消息传来了....

---
## 2019年1月25日
1. 开发线形空域编辑逻辑
2. 开发空域成功后回调逻辑
3. 开发首页电子围栏逻辑，进度60%

---
## 2019年1月28日
1. 添加首页空域围栏逻辑
2. 修改首页飞机详情页UI
3. 添加空域成功后返回空域类型入参
4. 今天中午本来要去健身，结果波哥要开会就没去上...

---
## 2019年1月29日
1. 添加批件输入公司名称逻辑
2. 修改添加空域返回字段类型
3. 添加空域回调aire数据
4. 添加联系人界面逻辑
5. 添加联系人和公司页back判空，添加联系人页最少添加一人逻辑
6. 添加空域引导页

---
## 2019年1月30日
1. 添加首页飞机飞行轨迹逻辑
2. 添加无人机详情信息自动更新
3. 添加首页按两次back键退出app
4. 今天就有一部分同事回家了，我的票还在抢，希望能抢到，提前两天到家

---
## 2019年2月13日
1. 今天休完了春节假期正式开始上班，今年不知道会有怎样的变化，房子也快到期了。
2. 修改首页崩溃问题
3. 修改空域添加点不可拖拽
4. 修改首页接口多次调用bug
5. 小宝宝长牙了，有一种小草发芽破土而出的感觉

---
## 2019年2月14日
1. 在纠结要不要看看外面的机会，其实很想留在京东，第一选择还是想内部异动
2. 昨天学习了下Flutter的基本原理
3. 整理了下简历，之前的简历确实有好多细节方面没有做好，改了很多，这样是不是也说明我进步了很多，所以才能知道以前不对的地方。

---
## 2019年2月15日
1. 运营平台国际版嵌入google地图，但是需要手机支持Google Play服务，在网上查目前国产手机都不支持这个，太坑了，看来还要找找其它方法
2. 学习了下安卓的类加载模式原理
3. 解决flutter编译正式包没有libflutter.so问题。windows要在编译命令加上指定的cpu类型。
flutter build apk --target-platform=android-arm64

---
## 2019年2月18日
1. 添加首页无人机飞行方向逻辑
2. 今天学习了flutter运行原理方面的知识，有一些知识是之前刚做flutter时看的，当时有一些东西看的似懂非懂，现在又看一次感觉理解了很多，
目前很想知道flutter运行时是怎么渲染界面和flutter如何与C++本地方法进行调用的。

---
## 2019年2月19日
1. 修改原生接口token
2. 今天看了下flutter原码，找到了flutter调用C++本地方法的地方，其实就是调用dart虚拟机的lib库，然后lib通过jni调用android的原生方法，进行
回调，然后flutter就能与原生通信了。
3. 感觉还是后端的工作机会多一些，最近公司论坛内部异动技术方面大都是后端的，前端的没有，看来有机会还是要学些后端的东西，到时可以转过去。
以后也不想再做业务方面的东西，想做平台层的一些专门做技术方面的，这样就不依赖业务的好坏和盈利而被砍掉了。

---
## 2019年2月20日
1. 学习了数据结构堆方面的知识

---
## 2019年2月21日
1. 搭建空域pad版项目框架，引入平台通用控件
2. 空域pad版工时评估，任务分配
3. 今天学习了数据结构和算法方面的图，准备把数据结构和算法的课程先整体学一遍，把学不明白的先跳过去，看完整体课程后再把之前看不明白的深入研究下，
这个是我在书上看到的新的学习方法，可以试试效果

---
## 2019年2月22日
1. 空域pad版首页UI开发
2. 学习了一些搜索算法方面的知识
3. 学习了dart调用C++方法的知识

---
## 2019年2月25日
1. 学习了c语言基础知识，终于明白了include的意思，以前一直不明白这块，感觉这块写着很奇怪，这块明白了也就知道c语言的项目要怎么处理项目结构
2. 得知同事因为犯了事被关进监狱了，这么年轻孩子也刚出生没多久，太可惜了，平时虽然跟这个同事接触比较少，但感觉这个同事人还可以，没想到会这样，
早上来的时候还在食堂见到他了，没想到上午就被警察带走了
3. 最近很迷恐怖黎明啊
4. 周末把房子定下来了，又续租了一年，希望今年可以留在京东，然后班车不要取消....第一季度还有一个月，希望第一个季度完事后我能被调走，祈祷吧。
然后这几天也要不断的学习，给自己的能力提高一下。我想把ios学习下，这样更能有助也我学习flutter这样的跨平台方案，可以理解两边的开发写法。在
传智播客找到了学习ios的视频，先从学c语言开始吧，比较这是oc的基础。
```c
include其实就是把代码直接复制到当前的文件中，一般c语言在使用一些函数时，需要先声明再使用。如果要使用别的文件的代码，就要使用include把
别的文件的.h文件包含进来，.h文件里写的都是函数的声明，并没有函数体，函数体都在与.h文件同名的.c文件中。
这样引入了.h文件，就可以使用.h中声明的函数了。多文件开发就是这个原理。
```

---
## 2019年2月26日
1. 今天学习了c语言的进制方面的知识
2. 运营平台国际版替换了所有的google地图和逻辑修改，昨天我把google需要的环境都安上了，但是google还是打不开，应该是不能翻墙的原因
3. 替换国际版单词过长的部分
```c
当声明一个变量申请一块内存区域的时候，所申请的地址都是从内存地址的最高位开始的，而变量的引用或指针所指的地址是低位的内存地址。
所有的数据在内存中都是以二进制来存储的，一个字节有8位，每个位都用0和1来表示。在内存中每个字节都有一个16进制的地址相对应。如int有4个字节，
就有32位，而左边第一位则是用来表示数据的正负的，只有31位是用来存储当前的数据的。
内存中，所有的数据都是使用二进制的补码来存储的，所有的正数的二进制的补码等于它的原码，所以不需要转换。而负数的就需要先把原码转成反码，然后再
把反码转成补码，这样做是因为计算机只能算加法，不会算减法，如果直接使用原码来处理减法最后的结果是错误的。
```
---
## 2019年2月27日
1. 学习了数组方面的知道，也理解了之前c语言中有数组为入参的方法为什么要传递数组的长度了，因为这个在java中是根本不需要的，所以这块一直没有
理解，写代码的时候也常常会忘记。
```c
int[] a = {1,3};
//a是数组第一个元素的最低位的地址，通过这个来找到数组，a[0]等于数组的第一个元素的值。
//在内存中申请地址都是从高位向低位来申请的，但是数据的第一个地址在低位。
test(a);
void test(int[] a)
{

}
//当一个函数以数组为入参的时候，调用函数时数组传递的是地址，而且函数接收时，实际是一个存储数组地址的变量。这个
//变量长度只有8个字节，使用这个地址是无法知道数组的长度的，所以在定义以数组为入参的方法时还要加上一个数组长度的
//入参才可以。
void test(int[] a，int len)
{

}
```
2. 学习了c语言中字符串的原理，因为在电脑的世界里是没有字符串这个东西的，只有8种基本数据类型，但要存储字符串就要依靠字符数组，字符数组每
一个元素都存着字符串中的每一个字符，然后在字符数组的最后一位加一个'/0'来表示字符数组结束，这样是有的数组很长，但里面存的字符并没有达到
数组的长度，'/0'后面都是垃圾值，所以要使用这种方法。字符数组要多申请一个字符长度用来存储'/0'
```c
char[] a = "dfa";
char[] b = {"daf"};
char[] c = {'a','b','/0'};
//下面的数组第二位到最后一位的数据都'/0'
char[5] d = {'a'}
```
3. 解决运营平台两处安全问题
4. 解决运营平台用户个人隐私数据调查

---
## 2019年2月28日
1. 本月的最后一天，也是发工资的日子，提前发工资的日子很好，但是也会感觉时间飞逝，第一季度也快完事了。今天得知波哥下周就要去商城的部门了，
不知道那边会怎样，希望能好些，到时那边有编制可以把我也调动过去，我也是不太想做业务方面的技术了，感觉天天写一样的代码没什么进步，还是得专门
研究技术比较好，这样才是真正的靠技术吃饭。
2. 上午的时候被同事告知，之前已经结项的项目他还有三个界面没做完，而且一直瞒着我到现在，这个本来是要年前做完的，结果到今天了才告诉我，真是太气人
了。天天上班做考研题学公务员也就算了，这点活还干不完，影响了本职工作，真是没见过这样的人，这种人去哪了都一样，估计公务员他也靠不上，以后写代码也
是要被淘汰的人。希望最近能把他裁掉。
3. 做了一个下午上面的同事说做不出来的日历控件，基本已完做完了，这个东西是有一点难度，但还没难到2个月都做不出来的程度吧，真是服了。

---
## 2019年3月1日
1. C语言字符串长度
```c
字符串的长度
char name[] = "jack";
这个时候字符数组name初始化的时候没有指定的长度，但是他的长度是5，因为要加上后面的'/0'
注意，sizeof输出上面数组的长度是5，其中包含最后一位的'/0'

char name[10] = "jack";
这个时候字符数组name初始化的时候有指定长度，他的长度度就10，只是使用到了前面5个字符，后面的值都是'/0'
注意，sizeof输出上面数组的长度是10
char name[] = "中国"
这个长度是7，因为一个中文占3个字节，但是不可以单独使用name[0] = '中'这样赋值，因为char只能占一个字节。
```
2. 字符数组注意点
```c
如果字符数组里中间的位置有'/0'字符，后面的字符会作废。
char str[] = {'a','b','/0','c'};
这里只会输出ab
```
3. 字符串的输入
```c
当输入的str里带有空格，sacaf函数里会认为空格表示输入结束，str里只会保持空格之前的数据，只能使用另外一个函数
char str[];
sacaf("%s",str);
```
4. 字符串常用函数
```c
下面两个函数在#include<stdio.h>中
puts()
作用:输出字符串，且自动换行，但只能输出字符串，也不能使用占位符。

gets()函数
作用:从控制台接收用户输入1个字符串数据，遇到字符串包含空格不会截断后面的字符串。缺点是不安全，入参数组的长度超出
时程序会崩溃

下面四个函数在#include<string.h>中
strlen()
作用:得到字符数组的字符串长度，返回值是size_t,是个unsigned long类型

strcmp()
作用:比较两个字符串的大小，返回负数说明字符串1比字符串2小，返回0说明相等

strcpy()
strcpy(name1,name2)
作用:拷贝数组数据到另外一个数组,把name2拷贝到name1，不安全，name1的长度可能比name2长度小，会产生崩溃

strcat()
strcat(name1,name2)
作用:把两个字符数组相连,把name2连接到name1的后面，不安全，name1的长度可能放不下两个数组的长度，会产生崩溃
```
5. 指针
```c
指针
变量的地址就叫指针，指针就是地址

指针变量
作用:是专门用来存储地址的变量，存储另外一个变量的地址。
使用指针变量的好外:间接访问指向的变量
int* p1;
*代表变量不是普通变量，而且用来专门存储地址的。这个p1指针变量只能存储地址。

指针变量的初始化
int num = 10;
int* p = &num;
而指针变量自身也是有地址的，使用&p就可以取出地址，其实就可以把指针变量当成一个普通的变量就行，只是存的值比较特殊。

使用指针变量操作指向的变量
int num =10;
int* p1 = &num;
*p1 代表p1指针指向的变量，也就是num
*p1 = 100; 将100赋值给p1指针指向的变量，也就是num

使用指针变量注意的问题
int* p1,p2,p3;
这样只有p1是指针变量，p2、p3都是int类型
如果希望都是指针应该这么写
int* p1,*p2,*p3;

野指针
声明一个指针变量，如果没有为其初始化，这个指针变量里是垃圾值，指向了一个随机的空间，这种
就是野指针。使用这样的指针如果指向的空间有被其它人使用会报BAD_ACCESS错误，但如果指向的空间是
无人使用的不会报错。
修改野指针还可能会造成别的程序崩溃。

NULL值
为了避免野指针出现，可以先给指针变量赋值为NULL。代表这个指针变量不指向内存中的任何地址
NULL等价于0，也可以给指针变量赋值为0,但不建议这样做。
int *p = NULL;
int *p1 = 0;
使用NULL的指针会直接报错

多个指针指向同个变量
int* p1 = &num;
int* p2 = p1;
这时p1和p2都指向num的地址，*p1和*p2访问的都是num变量。

指针用在什么地方
当普通变量作为函数的参数时，在函数中无法改变入参的值。
void test(int* p)
{
   *p = 1000;//这里会改变num的值
}
int num = 0;
test(&num);

什么时候需要将指针作为函数入参？
1. 当函数的返回值大于一个以上时。可以在函数的入参加上指针。
int getMaxAndMin(int arr[],int len,int* min)
{
	int max = INT32_MIN;
	*min = INT32_MAX;
	for(int i =0;i<len;i++)
        {
            if(arr[i] > max)
            {
                 max = arr[i];
             }
             if(arr[i] < *min)
             {
                 *min = arr[i];
              }
         }

         return max;
}
第二个例子，这样scanf直接就改变了num的值。
int num = 0;
scanf("/d",&num);

指针为什么要分类型
任何类型的指针都占8个字节。因为指针变量可以存储任何变量的地址，但无法知道所存变量的类型长度，
所以要指定指针变量的类型。
int num = 10;
int* p = &num;
p指针变量中存储的是num变量的低位的地址，所以知道变量类型的话就能找到所指向的变量在内存中的
长度，就能知道可以连续操作多少个字节空间。int* 就可以连续操作4个字节，double*能操作8个字节的内存空间。

多级指针
一级指针
只能存储普通变量的地址
int num = 10;
int* p = &num;

二级指针
只能存储一级指针变量的地址
int** p1 = &p;

三级指针
只能存储二级指针变量的地址
int*** p2 = &p1;

二级指针的使用
int num = 10;
int* p1 = &num;
int** p2 = &p1;
*p1 = 200;
*p2 //代表p2指针指向的变量，也就是p1的地址
int age = 10;
*p2 = &age;// 这里的*p2的值是p1的地址，然后p1保存了age的地址
**p2 //代表p2指针所指向的指针所指向的变量
**p2的值为10
```
---
## 2019年3月4日
1. c语言
```c
指针与整数的加减法
指针与整数进行加减运算
比如指针+1，并不是在指针的基础之上加1个字节的地址，而是跟在这个指针基础之上加1个单位变量占用的字节数。
如果指针类型是int* 那么1代表4个字节地址。
如果是double*，那么1代表8个字节地址
int num1 = 10;
int num2 = 20;
int* p1 = &num2;
int* p2 = p1+1;

指针与数组
一维数组在内存中是连续的空间
int arr[3] = {10,20,30};
一维数组的地址
是数组的低字节的地址
数组名就是数组的地址

定义一个指针指向数组中的元素
int* p0 = &arr[0];
int* p1 = &arr[1];
int* p2 = &arr[2];
*p0 = 100;
*p1 = 200;
*p2 = 300;
数组中的元素值改变。
int* p3 = arr;//与p0相等

*(p3+1)与*p3+1的值不一样
因为*运算符比+运算符的优先级别要高，所以会先运算*p3的值，然后再加1

使用指针遍历数组
第一种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(p3+i));
}
第二种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(arr+i));
}
第三种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(p3++));
}
注意每次循环后p3的指针都指到数组外面去了，就不再指向数组中的元素了，
所以再次遍历要重新赋值
但不能使用*(arr++),因为数组名代表数组地址，数组一但创建地址就确定了，是
不能改变的。

数组作为函数参数
在声明这个参数数组的时候，并不是创建一个数组，而是去创建1个用来存储地址的指针变量。
编译在编译的时候，已经把这个数组换成了指针
void test(int arr[],int len)
{

}
变成,建议写成这种方式
void test(int* arr,int len)
{

}
```
2. 修改日历控件能切两个日历，但引入了一些Bug，目前还有一个箭头的bug要解
3. 从今天开要开两会，我们的班车也要换到白庙收费口那上车了，每天要转车然后走过去，好累

---
## 2019年3月5日
1. 改了一天日历控件bug
2. 添加日历控件第一次启动时显示数据为空
3. 修改日历控件显示月份为中文

---
## 2019年3月6日
1. c语言学习
```c
存储int指针的数组
int num = 100;
int num = 200;
int* arr[3] = {&num,&num1}
//改变指针数组里指针变量所指向的变量的值
*(arr[0]) = 3000;
//该变指针数组里指针指向的变量地址
int num3 = 300;
arr[1] = &num3;

指针和指针之间可以做减法运算，但结果是1个long类型的数据。代表的是两个指针变量之间相差
多少个单位变量。绝大多数情况下用在判断数组两个元素之间相差多少个元素。
如果参与减法运算的两个指针不指向同一个数组结果就会有问题。
int* p1 = &num1;
int* p2 = &num2;
long res = p2 -p1;

指针之间的比较运算
先声明的变量的地址要大于后声明的变量的地址，因为先声明的变量地址在高地址。
p1 > p2

内存中的五大区域
栈
专门用来存储局部变量

堆
允许程序员手动的从堆申请空间来使用。程序员自己申请指定字节数的空间。

BSS段
存储未初始化的全局变量和静态变量

数据段/常量区
用来存储已经初始化的全局变量、静态变量，还有常量。

代码段
用来存储代码/指令

为什么要分五个区域?每个区是干嘛的?
不管是哪个区域都是用来存储数据的。
不同的数据存储在不同的区域，方便系统管理。

存储字符串的两种方式的区别
1.使用字符数组来存储:将字符串数据的每1个字符存储到字符数组的元素中，
追加1个'\0'表示结束。
char name[] = "jack";
2. 使用字符指针来存储:直接为字符指针初始化1个字符串数据
char* name = "jack";
区别
char name1[] = "jack";
char* name2 = "jack";
1. 当他们都是局部变量的时候
name1字符数组是申请在栈区，字符串的每一个字符存储在这个字符数组的
每一个元素中。
name2这个指针变量是声明在栈区的，字符串数据是存储在常量区中的。
字符串数据就是以字符数组的形式存在常量区的，把地址给栈中的指针变量。
2. 当他们作为全局变量的时候
name1是在常量区的内存中存储的。
name2指针变量也在常量区中，并且指向存在常量区中的数组地址
区别对比
1.申请内存存储的区域不同
2.name1字符数组不管是局部和全局的，里面的元素是可以修改的
不管是全局的还是局总的变量name2以字符指针变量声明的字符数组是不可以修改的
```
2. 修改日历控件第一次不默认选中日期
3. 修改日历控件确定按钮逻辑
4. 开发空域管理Pad版首页UI和部分逻辑
5. 同事们都因为要被裁员而不干活了，感觉多干了自己就吃亏了，其实我觉得吃亏的是自己，尤其是自己的声誉上，被领导贴上了不靠谱的标签。
以后领导再有好的机会可能就不会考虑这样的人了。我是觉得能干一天就要做一天的活，毕竟还领着公司的钱，而且自己也能被领导所看好，觉得
你比别人都靠谱。

---
## 2019年3月7日
1. c语言学习
```c
字符串的恒定性
大前提:是以字符指针形式存储的字符串。
1. 当我们以字符指针的形式存储字符串的时候，无论如何字符串数据都是存储在常量区中。
并且一旦存储到常量区中去，这个字符串数据就无法更改。
2. 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到
常量区，而是先检查常量区中是否有相同内容的字符串。
如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储在常量区。
3.当我们重新为字符指针初始化1个字符串的时候，并不是修改原来的字符串，而是重新创建了1个字符
串，把这个新的字符串的地址赋值给它。
4.容易混淆的地方
char *name = "jack";
name = "rose";
这样是可以的，只是在常量区新创建了一个rose字符串
char name[] = "jack";
name = "rose;
这样是不行的，因为name代表的是数组名称，不能为数组名赋值，可以使用下面的方式改变数组内容。
name[0] = 'r';
name[1] = 'o';

字符串数组
1. 使用一个二维字符数组来存储多个字符串，每一行都是一个字符串。
这个数组的每一行是1个长度为10的char一维数组。
但每1个字符串的长度不能超过列数减1，也就是9个
char name[][10] = 
{
   "jack","rose"
};
2.使用字符指针数组
char* name[4] = {"jack","rose"};
每个元素的类型是char指针,初始化给元素的字符串数据是存储在常量区的，元素中存储的是字符串在
常量区的地址。
使用这种方式的好处是每个字符串的长度无限制。

const关键字
用来修饰变量。一般情况下来说，变量具备一定程度上的不可变性。
1.const修饰基本数据类型的变量
const int num = 10;
int const num = 10;
这两种效果一样，都不能再次赋值
2.const修饰数组
const int arr = {10,20};
arr[0] = 100;这里是错的，元素不能修改
3.const修饰指针
int num = 10;
const int* p = &num;
*p = 20;//这里不能修改，报错
无法通过指针去修改指针指向的变量的值。但直接操作变量是可以修改的。
int num2 = 10;
*p = &num2;
但指针变量的值可以修改。可以把另外一个变量的地址赋值给这个指针。
int const *p1 = &num1;
效果同上
int * const p1 = &num;
int age = 20;
p1 = &age;//这里报错
*p1 = 100;//这里可以
int const * const p1 = &num;
这里什么都不可以改

const使用场景
1.const特点
被const修饰的变量是只读变量，只有取值不能改值。
2. 不允许别人去修改值的时候使用
3. 当函数的参数是一个指针的时候，函数的内部有可能会修改实参变量的值。
可以给函数的参数加一个const来修饰，这样函数内部就无法修改了，保证了数据的安全性。
void test(const int * num)
{

}


如何向堆区申请字节空间来使用
1. 我们在堆中申请的字节空间，如果我们不主动释放，那么系统是不会释放的，除非程序结束。
2. 在堆中申请字节空间的步骤
申请
使用
释放
3. 如何在堆区申请指定的字节数的字节空间呢
malloc()
calloc()
realloc()
这三个函数的声明在stdlib.h的系统头文件中。
4. malloc函数
int* p1 = malloc(4)
参数只有一个，是size_t类型也就是unsigned long。
作用是向堆空间申请指定字节的空间来使用。
参数代表的意义是，向堆内存申请多少个连续的字节空间。
返回值是void *，代表没有类型的指针。返回的是创建的空间中第一字节的地址。地址没有类型。
int* p1 = malloc(8);
p1操作的时候是以4个字节为基本单位。
5. 在堆区申请的空间是从低地址向高地址分配的。
且每次申请的字节地址都是从0开始的，每次申请的字节空间不一定是连续的。但是每次申请的指定个
字节，这些字节一定是连续的。
6. 在堆区申请的字节，里面是垃圾值，不会自动清0。
7. 在向堆区申请字节空间的时候，有可能会申请失败。如果申请失败返回的指针是NULL值。
我们申请完空间之后，最好是判断一下，是否申请成功。
int* p1 = malloc(12);
if(p1 != NULL)//判断申请成功
if(p1)//这样也可以判断申请成功
8. 申请完的空间一定要记得释放
free(指针);
free(p1);

calloc函数
优点是，申请完空间之后，系统会将字节中的数据清零。
calloc(size_t,size_t)
申请3个int类型的字节空间，也就是12个字节空间
int* p1 = calloc(3,sizeof(int));

realloc函数
作用是扩容，当我们发现我们之前在堆区申请的字节空间不够用的时候可以使用realloc函数
int *p1 = calloc(3,sizeof(int));
int *p2 = realloc(p1,4);
如果原来的空间后面还有剩余的空间，且足够扩容，则直接在后面的空间扩容。
不够的话重新找一块足够的空间，将原来的数据拷贝过来，原来的空间被自动释放。

指针与函数
1.指针作为函数的参数
在函数内部可以通过这个参数指针去修改实参变量的值

2.指针作为函数的返回值
下面是错误的代码
int* test()
{
  int arr[] = {10,20};
  return arr;
}
int* arr = text();
这样是错误的，因为test函数中的arr数组在test函数执行完成后被回收了，它是一个局部变量。
不能返回局部变量的地址。
如果要返回一个指针，要保证这个指针指向的空间在函数结束后仍然存在。
那么这个时候，就可以将空间申请在堆区，然后返回堆区的地址。一定要记得，调用者使用完了之
后一定要释放掉内存。
下面是改正后的代码
int* test()
{
  int* arr = calloc(3,sizeof(int));
  return arr;
}

如果函数的返回值是字符串，那返回值类型就是char*。
字符串常量存储在常量区里，可以直接返回这个字符串的地址，不用在堆区申请空间。
申请在常量区的空间是不会被回收的。
char* getWeekDay(int day)
{
  return "monday";
}
```
2. 修改运营平台国际版崩溃问题
3. 我们大组今天说明天晚上要去团建，我们组的人大部分都是要被裁员的，都没什么心情去。

---
## 2019年3月8日
1. c语言学习
```c
指向函数的指针
声明方式
返回值类型(*指针名)([参数列表]);
只能指向没有返回值，并且没有参数的函数。
void (*pFunction))();
int (*pFun)(int num1,int num2);
函数名代表函数的地址
void test(){}
void (*pFunction)() = test;
如何调用函数指针,下面两种方式都可以
pFunction（）
(*pFunction)()

结构体
struct 新类型名称
{

};
struct student
{
   int age;
   char* name;
};
上面只是声明了一个结构体类型，在使用时还需要再声明一个结构体变量。这个时候才会在内存中申请空间。
struct 新类型名称 变量名;
struct Student stu;
stu.name = "jack";
stu.age = 10;
匿名结构体
不可以再创建新的变量
struct
{
   int age;
   char* name;
} jeo;

结构体变量的初始化
1.先声明变量，再用.初始化
2.直接初始化，这种最常用
struct student lili = {"jack",20}
3.在声明结构体变量的同时，按顺序初始化部分成员
struct Student lili = {"li"};
4.指定成员初始化
struct Student jim = {.name = "ji",.age = 10};

结构体变量的成员的默认值
结构体变量的成员的默认值是垃圾值，只要在声明结构体变量的同时，只要初始
化1个成员，其它的成员都会被自动初始化为0

相同的结构体变量之间是可以相互赋值的，结构体之间赋值是值传递
struct Student jim = {.name = "ji",.age = 10};
struct Student li = jim;

结构体数组
元素类型 数组名[数组长度]
struct Student stu[5];
stu[0] = jim;
初始化方式
1.通过下标为结构体每个元素赋值
2.当我们为结构体数组的元素赋值的时候，如果直接使用大括弧来初始化，就必须
要在前面加个类型强转，告诉编译器我们要给的数据类型是结构体类型。
sut[0] = (struct Student){"qiao",12};
3.在声明结构体数组的同时，就给元素初始化。
struct Student stu[5] = {{"qiao",12}，{"jeo",12}};

结构体数组的长度计算
先使用sizeof计算出数组占用总的字节数，使用这个总字节数除以每1个元素占用的字节数。
int len = sizeof(stu) / sizeof(struct Student);

结构体指针
struct student lili = {"jack",20}
struct Student* pStu = &lili;
结构体指针访问结构体里的变量成员两种方式
(*pStu).name = "qqq";
pStu->name = "rose";

结构体嵌套
struct Date
{
  int year;
};
struct Person
{
  char* name;
  int age;
  struct Date birthday;
};
初始化
struct Person xiaoming = {"xiao",21,{1990}};

结构体作为函数的参数
结构体作为参数传值是值传递，除非传入的是结构体指针
void test(struct Student stu)
{
  
}
void test(struct Student* stu)
{
  
}

结构体作为函数的返回值
1.结构体类型可以作为返回值，
struct Student getStudent()
{
   struct Student s1 = {"qiao",21};
   return s1;
}
下面的代码是错误的，因为s1是局部变量，函数执行完成后就被销毁了。
struct Student * getStudent()
{
   struct Student s1 = {"qiao",21};
   return &s1;
}
如果要返回指针需要在堆内存中申请内存空间
struct Student * getStudent()
{
   struct Student *s1 = calloc(1,sizeof(struct Student));
   s1->name = "rose";
   return s1;
}

枚举
数据类型的变量的取值被限定
enum 新类型名称
{
   限定取值1，限定取值2，限定取值3
};
enum Dir
{
  East,
  South,
  West
};
表示新创建了1个数据类型，数据类型叫enum Dir

声明枚举类型变量
enum Dir dir;

注意
1.每一个枚举值都有一个对应的整形的数。默认从0开始，依次递增。
2.无论什么类型的枚举变量都占4个字节
3.枚举变量中真正存储的是枚举值对应的整型的数。
4.枚举值还可以重新赋值
enum Dir
{
  East = 10,
  South = 20,
  West =30
};

枚举使用规范
1.命名规范，首字母大写，每个单词的首字母大写。
2.枚举值的命名规范，枚举值的名称都以枚举类型来开头。

typedef
作用：为一个已经存在的数据类型取一个别名，如果我们想使用这个类型，直接使用这个别名
就可以了。
语法格式
typedef 已经存在的数据类型 别名;
typedef int qInt;
qInt num = 10;
经常使用的的size_t其实就是unsigned long，只是被取了别名而已
什么时候使用？
当数据类型很长的时候，就可以为这个数据类型取一个短一点的别名，这样使用方便。
unsigned long long int num =10;
typedef unsigned long long int hm;
hm num1 = 100;

为结构体使用typedef，声明一个短别名,分别有以下三种方式
第一种
struct student
{
   int age;
   char* name;
};
typedef struct Student stu;
第二种
typedef struct student
{
   int age;
   char* name;
} stu;
第三种
为匿名结构体使用typedef声名一个短名，最常用的方式

typedef struct
{
   int age;
   char* name;
} stu;
再使用的时候可以直接用下面的形式
stu s1;

使用typedef为枚举类型取一个短别名,两种方式
第一种
enum Direction
{
  East,
  South
};
typedef enum Direction Direction;
第二种
typedef enum Direction
{
  East,
  South
} Direction;

第三种
typedef enum
{
  East,
  South
} Direction;
直接使用
Direction dir = East;
```

---
## 2019年3月11日
1. c语言学习
```c
宏定义
它是一个预处理指令，所以它在编译之前执行。
可以为1段C代码定义一个标识
语法
#defing 宏名 宏值
#defing N 10
如何使用
在c代码中直接使用宏名就可以了
int a = N + 1;
宏的原理
在预编译的时候，就会执行源文件中的预处理指令
会将c代码中使用宏名的地方替换为宏值
在使用时要注意的地方
1.宏值可以是任意的东西，在定义的时候并不会检查语法
2.如果宏是一个表达式，使用时不会得到表达式的结果，而是直接替换为表达式
3.如果宏值如果有变量名，要保证使用前变量已经被定义
4.从定义宏的地方，后面的所有地方都可以直接使用，宏没有作用域
5.字符串中如果出现宏名，系统不会认为这是一个宏，而认为是字符串的一部分
6.宏的层层替换，
#define PI 3.14
#define R 3
#define AREA PI * R * R
AREA的宏值是3.14 * 3 * 3
doubel area = AREA;
7.如果定义宏的时候加了分号，宏值里会包括分号
解除宏指令
#undef N
作用
从解除宏指令之后的代码都不可以使用宏定义了

宏值带参数
#define N(a) a + a + a
int b = N(10);
宏代替的原理
1.先将传入的值传递给宏的参数，那么宏的参数的值就是我们传递的值
2.再把这个宏值当中使用的参数的地方换成参数的值
3.最后再将使用宏名的地方替换为最后的宏值

使用带参数的宏几点注意
1.宏不是函数，所以宏的参数不需要加类型，直接写参数名就行
2.在定义宏的时候，编译器是如何区别宏名和宏值的？
#define 空格 (中间的这块会当做宏名) 空格
所以在写宏的时候，空格要小心使用
3.为带参数的的传值是本色传递
int a = 10;
int b = N(a);
这里的N接收的只是a，并不是变量a的值，预编译期间得不到变量的值
4.宏值一旦换行就认为宏定义结束了，只有当代码很少的时候，才使用宏

条件编译指令
1.它是一个预处理指令，所以只能在预编译阶段执行。
2.作用
默认情况下，我们所有的C代码都会被编译为二进制代码，
条件编译指令的作用是可以让编译器只编译指定部分的代码。

用法
在预编译的时候，如果条件成立，就会将其中的C代码编译成二进制指令，
如果不成立，就不会将其中的c代码编译成二进制指令。

注意:
条件只能是宏，不能是变量
第一种用法
#if 条件
   c代码
#endif

示例
#define N 10
#if N = 10
printf("sdfasdf");
#endif

第二种用法
#if 条件
   C代码
#elif 条件
   C代码
#elif 条件
   C代码
#else
   C代码
#endif
其中#endif是必须要写的

第三种用法
如果定义了宏名，就编译其中的代码
#ifdef 宏名
   C代码
#endif

如果没有定义宏名，就编译其中的代码
#ifndef 宏名
   C代码
#endif

解决多文件使用#include被包含多次问题
#ifndef 宏名
#define 宏名 
  代码
#endif

static和extern
可以用来修饰变量和函数
1.修饰局部变量效果
static修饰局部变量
如果局部变量被static修饰，这个变量叫静态变量。
静态变量不再存储在栈区，而是存储的常量区
当函数执行完毕，这个变量不会被回收。
当再次执行局部变量时，声明静态变量这行代码会直接被跳过，不会再重复声明
实例
void test()
{
   static num = 1;//当函数第二次及以上被调用的时候，这行代码会被跳过
   num++;
}

2.修饰全局变量
当我们分模块开发的时候，如果要在模块中声明全局变量
1.全局变量的声明要写在.h文件中
2.全局变量的实现要写在.c文件中
3.如果将全局变量定义在模块中，这个全局变量就必须要使用static或者exter修饰
static和exter区别
使用extern修饰，这个模块中的全局变量就可以跨模块访问
使用static修饰，这个模块中的全局变量只能在当前模块中访问

static和extern修饰函数
static修饰的函数只能在当前模块中调用，无法跨模块调用
如果声明的函数没有用static修饰，那么它默认就是使用extern修饰的，可以跨模块调用

```
```oc
OC与C的不同
1.在c的基础上新增了1小部分面向对象语法
2.将c的复杂、繁琐的语法进行了封装，使用更为简单
3.oc完全兼容c语言
4.OC程序的源文件的后缀名是.m，m表示message，代表oc中最重要的1个机制，消息机制
5.#import指令
是一个预处理指令，是#include指令的增强版，将文件的内容的预编译的时候拷贝到指令的地方。
同一个文件无论#import多少次，只会包含1次。
原理:
底层会先判断这个文件是否被包含，如果被包含就会略过
6.框架
框架是一个功能的集合，苹果或者第三方事先将一些程序在开发程序时经常会用到的功能事先写好，
把这些功能封装在多个类或者函数之中，这些类和类的集合就叫框架，有点像c语言的函数库。
7.Foundation框架
这个框架提供了最基础的功能，输入和输出还有一些数据类型。
Foundation.h文件当中包含了Foundation框架中其它的所有的头文件
所以只要包含Foundation.h，就相当于包含了Foundation框架中所有的头文件。
那么Foundation框架中所有的函数和类就可以使用了。
8.@autoreleasepool是自动释放池
```
2. 今天被拘留的同事回来了，听说是因为打架的原因，感觉很不值当啊，但是有的时候就是脾气上来了，控制不了。
3. 组里有个同事异动去了别的组，然后另外一个同事也准备提离职的，还有一些人就等着被裁员，感觉组里的每个人都没有心思在这了
4. 今天把所有的c语言基本学完了，开始学习oc基础。在学习的过程中收获还是很大的，以前通过看书自学的时候，进度慢而且有些知识还看
不太明白理解不了，看视频学习感觉很多知识由老师一讲出来，感觉理解的很清楚，以前一些没明白的知识瞬间就明白了，也了解了程序运行
的一些原理，对自己之前学习的很多知识起到了一个串联的做用。看来学习C语言确实是对编程方面有很大帮助的。

---
## 2019年3月12日
1. oc语言学习
```oc
NSString
NSString类型是指针变量，专门用来存储OC字符串的地址。
OC字符串常量必须要使用1个前缀@符号
NSString *str = @"jack";
NSLog(str);//直接输出字符串
NSLog(@"大家好，我是%@",str);//使用%@来当占位符

NS前缀是什么
NextStep公司被评估收购，改名为Cocoa，被加入到Foundation框架中。
NS表示这个类是由NextStep公司写的。

@符号是什么
作用:
1.将c字符串转为oc字符串
2.OC中绝大部分关键字都是以@符号开头

OC程序的编译、链接、执行
1.在.m文件中写上OC源代码
2.使用编译器将源代码编译为目标文件
cc -c xx.m
3.链接
cc xx.o -framework Foundation
-framework Foundation是链接OC程序必须要加的，c语言不用加
如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉
编译器去哪个框架中找类。
4.链接成功后会生成一个a.out可执行文件

OC当中的数据类型
1.OC中支持C语言中的所有数据类型
2.BOOL类型
可以存储YES或者NO中的任意1个数据
一般情况用来存储条件表达式的结果
BOOL本质是
typedef signed char BOOL;
实际上BOOL类型的变量是1个有符号的char变量
#define YES((BOOL)1)
#define NO((BOOL)0)
平时开发主要使用BOOL
3.Boolean
可以存储true或者false
4.class类型 类类型
5.id类型 万能指针类型
6.nil 与NUll差不多
7.SEL 方法选择器
8.block 代码段

OC面向对象
类的声明
@inteface 类名 : NSObject
{
   //变量的声明写在这里
}
//方法的声明写在这里
@end

类的实现
@implementation 类名
//将方法的实现写在这里
@end

示例
@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
@end

@implementation Person

@end

注意点:
1.类必须要有声明和实现
2.类名的首字母要大写
3.变量必须要定义在@interface的大括号之中
4.变量名要用下划线开头

创建对象
对象的本质是一个C语言的结构体
语法：
类名 *对象名 = [类名 new];
Person *p1 = [Person new];

如何使用对象
访问对象属性
默认情况下，对象的属性是不允许被外界访问的，
如果允许对象属性可以被外界访问，那么在声明属性时要加一个@public
p1->_name = @"jack";//平时开发要使用->这种方式
p1->_age = 19;
(*p1)._name = @"jack";

OC的方法
示例
@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
方法的声明写这里
- (返回值)方法的名称;
- (返回值)方法的名称:(参数类型)形参名称;
- (返回值)方法的名称:(参数类型)形参名称1 :(参数类型)形参名称2;
@end

@implementation Person
方法的实现写这里
@end

@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
- (void)run;//声名一个无返回值无参数的方法
- (void)eatWith:(NSString *)foodName;//注意，方法的名字叫eatWith:,如果方法只有一个入参，方法名最好
加上With，这样易读性更好,是一种规范
- (int)sum:(int)num1 :(int)num2;//注意，方法的名字叫sum: :
- (int)sum:(int)num1 and:(int)num2;//注意，方法的名字叫sum: and:,加上and更加易读
@end

@implementation Person
- (void)run
{
   NSLog(@"fsdafdasf");
}
- (void)eatWith:(NSString *)foodName
{
    NSLog(@"fsdafdasf%@",foodName);
}
- (int)sum:(int)num1 :(int)num2
{
    return num1 + num2;
}
- (int)sum:(int)num1 and:(int)num2
{
    return num1 + num2;
}
@end

如何调用方法
[对象名 方法]
Person *p1 = [Person new];
[p1 run];//调用无入参的函数
[p1 eatWith:@"iii"];//调用有一个入参数的函数
int sum = [p1 sum:10 :20];
int sum = [p1 sum:10 and:20];

类的加载
在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的
代码段区域，这个过程叫做类加载。
只有类在第一次被访问的时候，才会做类加载，一个类只会被加载一次。直到程序
结束之后才会被释放。

对象在内存中究竟是如何存储的
Person *p1 = [Person new];
Person *p1;//会在栈内存中申请一块指针变量的空间
[Person new];//真正在内存中创建对象的其实是这句代码
new做的事情
1.在堆空间中申请1块合适大小的空间
2.在这个空间中根据类的模板创建对象，类模板中定义了什么属性，就把这些
属性依次的声明在对象之中，对象中还有另外一个属性叫做isa，是一个指针，
它指向对象所属的类在代码段中的地址
3.初始化对象的属性
如果属性的类型是基本数据类型，那么就赋值为0
如果属性的类型是C语言的指针类型，那么就赋值为NULL
如果属性的类型是OC的类指针类型，那么就赋值为nil
4.返回对象的地址

注意
1.对象中只有属性而没有方法。
2.如何调用方法
[指针名 方法名];
先根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类，
然后再调用类里的方法。
3.为什么不把方法存储在对象之中
因为每一个对象的方法代码实现都是一模一样的，没必要为每一个对象都保存1个
方法，太浪费空间，所以只把方法存储在代码段就可以了。

nil
只能作为指针变量的值。
nil其实也等价也0，也是一个宏。
nil与C语言的NULL是一样的，两个值相等。
虽然使用NULL的地方可以使用nil，但不建议这样做。

分组导航标记
主要是用来给代码文件添加一种特殊的注释用的，要结合Xcode使用
#pragma mark 分组名
会在导航条对应的位置显示1个标题
#pragma mark -
会在导航条对应的位置显示1条水平分隔线
#pragma mark - 分组名
会在导航条对应的位置显示1条水平分隔线，再显示标题

OC中注意点
1.属性名一定要以下划线开头
2.属性不允许在声明的时候初始化或赋值
3.如果方法只有声明没有实现，在调用时会报错
```
2.今天开始学习oc语言了，学习完c语言确实能更有助于学习oc的一些知识，主要是内存方面的更好理解，这样可以更好的使用内存和优化性能

