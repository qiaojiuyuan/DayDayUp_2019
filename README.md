# DayDayUp_2019
2019年学习工作历程记录

---
## 2019年1月7日
1. 元旦请了三天假，连上了周末两天，休了一个小长假，本来很开心可以多看看女儿，没想到我发烧了，然后又传染给了女儿，女儿直接住院了，我也不能离她太近，
怕再传染给她。我昨天坐火车走了，她还没有出院，希望今天晚上不发烧明天可以出院。
2. 今年形式很严峻，裁员的公司很多，一个岗位有很多人竞争，必须要抓紧时间学习了，没有紧迫感最后都是要被淘汰的，尤其是程序员这行。最近准备整理下学习计划，
3. 今天把运营平台项目中所有的中文字符转成翻译好的英文了
4. 感冒还没好利索，头疼

---
## 2019年1月8日
1. 修改运营平台海外版翻译错误
2. 调研海外版地图，目前谷歌和腾讯均要收费，明天看看百度地图
3. 开发通过点击地图添加圆型空域圆心
4. 开发多边形空域点击地图添加点
5. 开发线形空域点击地图添加点
6. 开发点按钮显示和隐藏逻辑

---
## 2019年1月9日
1. 添加空域点列表可滑动到当前下标
2. 添加提交按钮

---
## 2019年1月10日
1. 添加空域点图片
2. 修改线形空域添加和删除点逻辑
3. 最近状态很差，干什么都干不进去，想学习看会pdf就看不进去了，很焦虑。昨天领导找我们组的每个人都谈话了，我感觉我们组有点危险....不知道最近会有怎样
的变化
4. 添加空域退出判空拦截逻辑

---
## 2019年1月11日
1. 心态很差，需要调整。还好姑娘今天出院了，终于都治好了，下次我再得病啥的可得离远点，要不全家人跟着一起遭罪。
2. 首页的UI逻辑和接口了解了下，下周准备做这块
3. 算法的大O表示法看了一点

---
## 2019年1月14日
1. 有可能被裁员，要开始看看面试题了...会认真的考虑下要不要转到西安
2. 中午去健身了

---
## 2019年1月15日
1. 看了一下数据结构和算法的知识，复习了一下数组、二分查找、跳表、快速排序、归并排序
2. 开发首页接口自动请求逻辑，和一些生命周期关闭接口自动请求逻辑
3. 开发首页网络状态监听广播，目前在注册和反注册方面还有问题，要找到一个比较好的注册和反注册的调用节点
4. 今天组里的同事进行了投票，选出组里贡献最多的人，没想到我会排在第一位，我以为我是后来的，跟大家都不熟悉，基本没什么人会投我，
结果让我比较意外，感谢大家，我是幸运的，要继续努力，虽然不知道年后我们组结果会怎样，但自己不能放弃，只有不断努力，才会更幸运。
也要给女儿做个榜样，要是连我都放弃了，家就完了

---
## 2019年1月16日
1. 中午健身了，工作变动的事看看年后怎么弄吧，尽量走异动，如果这次我再离开京东估计这辈子基本上就进不来了
2. 开发提交空域逻辑，接口目前有问题
3. 开发提交判空逻辑
4. 学习了LinkedHashMap原理，但还有点不太理解，明天再看一次

---
## 2019年1月17日
1. 开发首页搜索无人机逻辑
2. 修改搜索界面数据解析错误问题
3. 把LinkedHashMap原理重新看了一次，理解了其中原理
4. 同事说他有可能会把北京房子卖了去苏州，感觉也不错，北京的生活确实太累，花300万只能买个又小又老的房子，但去苏州就不一样了，生活
质量能提高很多。我们普通的打工者，目前真是没有办法在北京立足，很多人都跟孩子异地，只有放假的时候才能看看孩子，感觉这样活着很难受。
我们努力只是想活的好点，但发现，你怎么努力也就那样，看不到头，只是存款多了些，那又怎么样呢，省吃俭用住着一个不足20平米的卧室，北京的
房子依然买不起，孩子也没办法来到身边。
人生就那么几年，活着到底是为了什么，总是说为了下一代，但我们自己呢，当前的生活我们选择负重前行，这没有错，也是应该做的，但要看牺牲的代价是
什么，更多的人牺牲的是自己的生活时间和健康，最后带来的是什么，如果身体健康是最好的，一但生病就什么都没了。这是一种不健康的生活状态，但这恰恰
是目前大多数人的生活方式。其实我们不想这样，只是没办法，只能扛着。

---
## 2019年1月18日
1. 开发首页搜索无人机逻辑，这块逻辑和界面今天找产品确认了下，重新做了
2. 哈希算法的应该看了下

---
## 2019年1月21日
1. 开发首页搜索无人机逻辑
2. 开发首页无人机列表逻辑
3. 开发无人机列表选中逻辑
4. 今天看了一下面试题，看了下热修复原理
5. 开发圆型空域高度和备降点逻辑，还差提交逻辑没写，完成度80%

---
## 2019年1月22日
1. 开发圆型空域高度和备降点逻辑
2. 修改提交空域崩溃Bug
3. 修改多边形空域点下标计算错误
4. 开发多边型空域高度和备降点逻辑
5. 今天发了春节礼包，感觉还不错
6. 最近一直在健身，希望年后了依然可以坚持...不过这个取决于工作，希望年后有好消息，今天波哥也跟我说了一些，还是有一点希望的

---
## 2019年1月23日
1. 添加首页电子围栏接口
2. 添加首页计划和申请计划跳转

---
## 2019年1月24日
1. 开发圆形空域编辑逻辑
2. 修改提交圆形空域缺少备降点bug
3. 开发空域编辑多边形逻辑
4. 今天开会，说了下年度绩效低会被裁员的事情，感觉很压抑，之前总听说经济不好公司会裁员，没想到会发生到自己身上，希望明年好运吧。
今天本来中午要去游泳，结果因为这个事没去上，看看明天能不能去，不希望再有坏消息传来了....

---
## 2019年1月25日
1. 开发线形空域编辑逻辑
2. 开发空域成功后回调逻辑
3. 开发首页电子围栏逻辑，进度60%

---
## 2019年1月28日
1. 添加首页空域围栏逻辑
2. 修改首页飞机详情页UI
3. 添加空域成功后返回空域类型入参
4. 今天中午本来要去健身，结果波哥要开会就没去上...

---
## 2019年1月29日
1. 添加批件输入公司名称逻辑
2. 修改添加空域返回字段类型
3. 添加空域回调aire数据
4. 添加联系人界面逻辑
5. 添加联系人和公司页back判空，添加联系人页最少添加一人逻辑
6. 添加空域引导页

---
## 2019年1月30日
1. 添加首页飞机飞行轨迹逻辑
2. 添加无人机详情信息自动更新
3. 添加首页按两次back键退出app
4. 今天就有一部分同事回家了，我的票还在抢，希望能抢到，提前两天到家

---
## 2019年2月13日
1. 今天休完了春节假期正式开始上班，今年不知道会有怎样的变化，房子也快到期了。
2. 修改首页崩溃问题
3. 修改空域添加点不可拖拽
4. 修改首页接口多次调用bug
5. 小宝宝长牙了，有一种小草发芽破土而出的感觉

---
## 2019年2月14日
1. 在纠结要不要看看外面的机会，其实很想留在京东，第一选择还是想内部异动
2. 昨天学习了下Flutter的基本原理
3. 整理了下简历，之前的简历确实有好多细节方面没有做好，改了很多，这样是不是也说明我进步了很多，所以才能知道以前不对的地方。

---
## 2019年2月15日
1. 运营平台国际版嵌入google地图，但是需要手机支持Google Play服务，在网上查目前国产手机都不支持这个，太坑了，看来还要找找其它方法
2. 学习了下安卓的类加载模式原理
3. 解决flutter编译正式包没有libflutter.so问题。windows要在编译命令加上指定的cpu类型。
flutter build apk --target-platform=android-arm64

---
## 2019年2月18日
1. 添加首页无人机飞行方向逻辑
2. 今天学习了flutter运行原理方面的知识，有一些知识是之前刚做flutter时看的，当时有一些东西看的似懂非懂，现在又看一次感觉理解了很多，
目前很想知道flutter运行时是怎么渲染界面和flutter如何与C++本地方法进行调用的。

---
## 2019年2月19日
1. 修改原生接口token
2. 今天看了下flutter原码，找到了flutter调用C++本地方法的地方，其实就是调用dart虚拟机的lib库，然后lib通过jni调用android的原生方法，进行
回调，然后flutter就能与原生通信了。
3. 感觉还是后端的工作机会多一些，最近公司论坛内部异动技术方面大都是后端的，前端的没有，看来有机会还是要学些后端的东西，到时可以转过去。
以后也不想再做业务方面的东西，想做平台层的一些专门做技术方面的，这样就不依赖业务的好坏和盈利而被砍掉了。

---
## 2019年2月20日
1. 学习了数据结构堆方面的知识

---
## 2019年2月21日
1. 搭建空域pad版项目框架，引入平台通用控件
2. 空域pad版工时评估，任务分配
3. 今天学习了数据结构和算法方面的图，准备把数据结构和算法的课程先整体学一遍，把学不明白的先跳过去，看完整体课程后再把之前看不明白的深入研究下，
这个是我在书上看到的新的学习方法，可以试试效果

---
## 2019年2月22日
1. 空域pad版首页UI开发
2. 学习了一些搜索算法方面的知识
3. 学习了dart调用C++方法的知识

---
## 2019年2月25日
1. 学习了c语言基础知识，终于明白了include的意思，以前一直不明白这块，感觉这块写着很奇怪，这块明白了也就知道c语言的项目要怎么处理项目结构
2. 得知同事因为犯了事被关进监狱了，这么年轻孩子也刚出生没多久，太可惜了，平时虽然跟这个同事接触比较少，但感觉这个同事人还可以，没想到会这样，
早上来的时候还在食堂见到他了，没想到上午就被警察带走了
3. 最近很迷恐怖黎明啊
4. 周末把房子定下来了，又续租了一年，希望今年可以留在京东，然后班车不要取消....第一季度还有一个月，希望第一个季度完事后我能被调走，祈祷吧。
然后这几天也要不断的学习，给自己的能力提高一下。我想把ios学习下，这样更能有助也我学习flutter这样的跨平台方案，可以理解两边的开发写法。在
传智播客找到了学习ios的视频，先从学c语言开始吧，比较这是oc的基础。
```c
include其实就是把代码直接复制到当前的文件中，一般c语言在使用一些函数时，需要先声明再使用。如果要使用别的文件的代码，就要使用include把
别的文件的.h文件包含进来，.h文件里写的都是函数的声明，并没有函数体，函数体都在与.h文件同名的.c文件中。
这样引入了.h文件，就可以使用.h中声明的函数了。多文件开发就是这个原理。
```

---
## 2019年2月26日
1. 今天学习了c语言的进制方面的知识
2. 运营平台国际版替换了所有的google地图和逻辑修改，昨天我把google需要的环境都安上了，但是google还是打不开，应该是不能翻墙的原因
3. 替换国际版单词过长的部分
```c
当声明一个变量申请一块内存区域的时候，所申请的地址都是从内存地址的最高位开始的，而变量的引用或指针所指的地址是低位的内存地址。
所有的数据在内存中都是以二进制来存储的，一个字节有8位，每个位都用0和1来表示。在内存中每个字节都有一个16进制的地址相对应。如int有4个字节，
就有32位，而左边第一位则是用来表示数据的正负的，只有31位是用来存储当前的数据的。
内存中，所有的数据都是使用二进制的补码来存储的，所有的正数的二进制的补码等于它的原码，所以不需要转换。而负数的就需要先把原码转成反码，然后再
把反码转成补码，这样做是因为计算机只能算加法，不会算减法，如果直接使用原码来处理减法最后的结果是错误的。
```
---
## 2019年2月27日
1. 学习了数组方面的知道，也理解了之前c语言中有数组为入参的方法为什么要传递数组的长度了，因为这个在java中是根本不需要的，所以这块一直没有
理解，写代码的时候也常常会忘记。
```c
int[] a = {1,3};
//a是数组第一个元素的最低位的地址，通过这个来找到数组，a[0]等于数组的第一个元素的值。
//在内存中申请地址都是从高位向低位来申请的，但是数据的第一个地址在低位。
test(a);
void test(int[] a)
{

}
//当一个函数以数组为入参的时候，调用函数时数组传递的是地址，而且函数接收时，实际是一个存储数组地址的变量。这个
//变量长度只有8个字节，使用这个地址是无法知道数组的长度的，所以在定义以数组为入参的方法时还要加上一个数组长度的
//入参才可以。
void test(int[] a，int len)
{

}
```
2. 学习了c语言中字符串的原理，因为在电脑的世界里是没有字符串这个东西的，只有8种基本数据类型，但要存储字符串就要依靠字符数组，字符数组每
一个元素都存着字符串中的每一个字符，然后在字符数组的最后一位加一个'/0'来表示字符数组结束，这样是有的数组很长，但里面存的字符并没有达到
数组的长度，'/0'后面都是垃圾值，所以要使用这种方法。字符数组要多申请一个字符长度用来存储'/0'
```c
char[] a = "dfa";
char[] b = {"daf"};
char[] c = {'a','b','/0'};
//下面的数组第二位到最后一位的数据都'/0'
char[5] d = {'a'}
```
3. 解决运营平台两处安全问题
4. 解决运营平台用户个人隐私数据调查

---
## 2019年2月28日
1. 本月的最后一天，也是发工资的日子，提前发工资的日子很好，但是也会感觉时间飞逝，第一季度也快完事了。今天得知波哥下周就要去商城的部门了，
不知道那边会怎样，希望能好些，到时那边有编制可以把我也调动过去，我也是不太想做业务方面的技术了，感觉天天写一样的代码没什么进步，还是得专门
研究技术比较好，这样才是真正的靠技术吃饭。
2. 上午的时候被同事告知，之前已经结项的项目他还有三个界面没做完，而且一直瞒着我到现在，这个本来是要年前做完的，结果到今天了才告诉我，真是太气人
了。天天上班做考研题学公务员也就算了，这点活还干不完，影响了本职工作，真是没见过这样的人，这种人去哪了都一样，估计公务员他也靠不上，以后写代码也
是要被淘汰的人。希望最近能把他裁掉。
3. 做了一个下午上面的同事说做不出来的日历控件，基本已完做完了，这个东西是有一点难度，但还没难到2个月都做不出来的程度吧，真是服了。

---
## 2019年3月1日
1. C语言字符串长度
```c
字符串的长度
char name[] = "jack";
这个时候字符数组name初始化的时候没有指定的长度，但是他的长度是5，因为要加上后面的'/0'
注意，sizeof输出上面数组的长度是5，其中包含最后一位的'/0'

char name[10] = "jack";
这个时候字符数组name初始化的时候有指定长度，他的长度度就10，只是使用到了前面5个字符，后面的值都是'/0'
注意，sizeof输出上面数组的长度是10
char name[] = "中国"
这个长度是7，因为一个中文占3个字节，但是不可以单独使用name[0] = '中'这样赋值，因为char只能占一个字节。
```
2. 字符数组注意点
```c
如果字符数组里中间的位置有'/0'字符，后面的字符会作废。
char str[] = {'a','b','/0','c'};
这里只会输出ab
```
3. 字符串的输入
```c
当输入的str里带有空格，sacaf函数里会认为空格表示输入结束，str里只会保持空格之前的数据，只能使用另外一个函数
char str[];
sacaf("%s",str);
```
4. 字符串常用函数
```c
下面两个函数在#include<stdio.h>中
puts()
作用:输出字符串，且自动换行，但只能输出字符串，也不能使用占位符。

gets()函数
作用:从控制台接收用户输入1个字符串数据，遇到字符串包含空格不会截断后面的字符串。缺点是不安全，入参数组的长度超出
时程序会崩溃

下面四个函数在#include<string.h>中
strlen()
作用:得到字符数组的字符串长度，返回值是size_t,是个unsigned long类型

strcmp()
作用:比较两个字符串的大小，返回负数说明字符串1比字符串2小，返回0说明相等

strcpy()
strcpy(name1,name2)
作用:拷贝数组数据到另外一个数组,把name2拷贝到name1，不安全，name1的长度可能比name2长度小，会产生崩溃

strcat()
strcat(name1,name2)
作用:把两个字符数组相连,把name2连接到name1的后面，不安全，name1的长度可能放不下两个数组的长度，会产生崩溃
```
5. 指针
```c
指针
变量的地址就叫指针，指针就是地址

指针变量
作用:是专门用来存储地址的变量，存储另外一个变量的地址。
使用指针变量的好外:间接访问指向的变量
int* p1;
*代表变量不是普通变量，而且用来专门存储地址的。这个p1指针变量只能存储地址。

指针变量的初始化
int num = 10;
int* p = &num;
而指针变量自身也是有地址的，使用&p就可以取出地址，其实就可以把指针变量当成一个普通的变量就行，只是存的值比较特殊。

使用指针变量操作指向的变量
int num =10;
int* p1 = &num;
*p1 代表p1指针指向的变量，也就是num
*p1 = 100; 将100赋值给p1指针指向的变量，也就是num

使用指针变量注意的问题
int* p1,p2,p3;
这样只有p1是指针变量，p2、p3都是int类型
如果希望都是指针应该这么写
int* p1,*p2,*p3;

野指针
声明一个指针变量，如果没有为其初始化，这个指针变量里是垃圾值，指向了一个随机的空间，这种
就是野指针。使用这样的指针如果指向的空间有被其它人使用会报BAD_ACCESS错误，但如果指向的空间是
无人使用的不会报错。
修改野指针还可能会造成别的程序崩溃。

NULL值
为了避免野指针出现，可以先给指针变量赋值为NULL。代表这个指针变量不指向内存中的任何地址
NULL等价于0，也可以给指针变量赋值为0,但不建议这样做。
int *p = NULL;
int *p1 = 0;
使用NULL的指针会直接报错

多个指针指向同个变量
int* p1 = &num;
int* p2 = p1;
这时p1和p2都指向num的地址，*p1和*p2访问的都是num变量。

指针用在什么地方
当普通变量作为函数的参数时，在函数中无法改变入参的值。
void test(int* p)
{
   *p = 1000;//这里会改变num的值
}
int num = 0;
test(&num);

什么时候需要将指针作为函数入参？
1. 当函数的返回值大于一个以上时。可以在函数的入参加上指针。
int getMaxAndMin(int arr[],int len,int* min)
{
	int max = INT32_MIN;
	*min = INT32_MAX;
	for(int i =0;i<len;i++)
        {
            if(arr[i] > max)
            {
                 max = arr[i];
             }
             if(arr[i] < *min)
             {
                 *min = arr[i];
              }
         }

         return max;
}
第二个例子，这样scanf直接就改变了num的值。
int num = 0;
scanf("/d",&num);

指针为什么要分类型
任何类型的指针都占8个字节。因为指针变量可以存储任何变量的地址，但无法知道所存变量的类型长度，
所以要指定指针变量的类型。
int num = 10;
int* p = &num;
p指针变量中存储的是num变量的低位的地址，所以知道变量类型的话就能找到所指向的变量在内存中的
长度，就能知道可以连续操作多少个字节空间。int* 就可以连续操作4个字节，double*能操作8个字节的内存空间。

多级指针
一级指针
只能存储普通变量的地址
int num = 10;
int* p = &num;

二级指针
只能存储一级指针变量的地址
int** p1 = &p;

三级指针
只能存储二级指针变量的地址
int*** p2 = &p1;

二级指针的使用
int num = 10;
int* p1 = &num;
int** p2 = &p1;
*p1 = 200;
*p2 //代表p2指针指向的变量，也就是p1的地址
int age = 10;
*p2 = &age;// 这里的*p2的值是p1的地址，然后p1保存了age的地址
**p2 //代表p2指针所指向的指针所指向的变量
**p2的值为10
```
---
## 2019年3月4日
1. c语言
```c
指针与整数的加减法
指针与整数进行加减运算
比如指针+1，并不是在指针的基础之上加1个字节的地址，而是跟在这个指针基础之上加1个单位变量占用的字节数。
如果指针类型是int* 那么1代表4个字节地址。
如果是double*，那么1代表8个字节地址
int num1 = 10;
int num2 = 20;
int* p1 = &num2;
int* p2 = p1+1;

指针与数组
一维数组在内存中是连续的空间
int arr[3] = {10,20,30};
一维数组的地址
是数组的低字节的地址
数组名就是数组的地址

定义一个指针指向数组中的元素
int* p0 = &arr[0];
int* p1 = &arr[1];
int* p2 = &arr[2];
*p0 = 100;
*p1 = 200;
*p2 = 300;
数组中的元素值改变。
int* p3 = arr;//与p0相等

*(p3+1)与*p3+1的值不一样
因为*运算符比+运算符的优先级别要高，所以会先运算*p3的值，然后再加1

使用指针遍历数组
第一种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(p3+i));
}
第二种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(arr+i));
}
第三种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(p3++));
}
注意每次循环后p3的指针都指到数组外面去了，就不再指向数组中的元素了，
所以再次遍历要重新赋值
但不能使用*(arr++),因为数组名代表数组地址，数组一但创建地址就确定了，是
不能改变的。

数组作为函数参数
在声明这个参数数组的时候，并不是创建一个数组，而是去创建1个用来存储地址的指针变量。
编译在编译的时候，已经把这个数组换成了指针
void test(int arr[],int len)
{

}
变成,建议写成这种方式
void test(int* arr,int len)
{

}
```
2. 修改日历控件能切两个日历，但引入了一些Bug，目前还有一个箭头的bug要解
3. 从今天开要开两会，我们的班车也要换到白庙收费口那上车了，每天要转车然后走过去，好累

---
## 2019年3月5日
1. 改了一天日历控件bug
2. 添加日历控件第一次启动时显示数据为空
3. 修改日历控件显示月份为中文

---
## 2019年3月6日
1. c语言学习
```c
存储int指针的数组
int num = 100;
int num = 200;
int* arr[3] = {&num,&num1}
//改变指针数组里指针变量所指向的变量的值
*(arr[0]) = 3000;
//该变指针数组里指针指向的变量地址
int num3 = 300;
arr[1] = &num3;

指针和指针之间可以做减法运算，但结果是1个long类型的数据。代表的是两个指针变量之间相差
多少个单位变量。绝大多数情况下用在判断数组两个元素之间相差多少个元素。
如果参与减法运算的两个指针不指向同一个数组结果就会有问题。
int* p1 = &num1;
int* p2 = &num2;
long res = p2 -p1;

指针之间的比较运算
先声明的变量的地址要大于后声明的变量的地址，因为先声明的变量地址在高地址。
p1 > p2

内存中的五大区域
栈
专门用来存储局部变量

堆
允许程序员手动的从堆申请空间来使用。程序员自己申请指定字节数的空间。

BSS段
存储未初始化的全局变量和静态变量

数据段/常量区
用来存储已经初始化的全局变量、静态变量，还有常量。

代码段
用来存储代码/指令

为什么要分五个区域?每个区是干嘛的?
不管是哪个区域都是用来存储数据的。
不同的数据存储在不同的区域，方便系统管理。

存储字符串的两种方式的区别
1.使用字符数组来存储:将字符串数据的每1个字符存储到字符数组的元素中，
追加1个'\0'表示结束。
char name[] = "jack";
2. 使用字符指针来存储:直接为字符指针初始化1个字符串数据
char* name = "jack";
区别
char name1[] = "jack";
char* name2 = "jack";
1. 当他们都是局部变量的时候
name1字符数组是申请在栈区，字符串的每一个字符存储在这个字符数组的
每一个元素中。
name2这个指针变量是声明在栈区的，字符串数据是存储在常量区中的。
字符串数据就是以字符数组的形式存在常量区的，把地址给栈中的指针变量。
2. 当他们作为全局变量的时候
name1是在常量区的内存中存储的。
name2指针变量也在常量区中，并且指向存在常量区中的数组地址
区别对比
1.申请内存存储的区域不同
2.name1字符数组不管是局部和全局的，里面的元素是可以修改的
不管是全局的还是局总的变量name2以字符指针变量声明的字符数组是不可以修改的
```
2. 修改日历控件第一次不默认选中日期
3. 修改日历控件确定按钮逻辑
4. 开发空域管理Pad版首页UI和部分逻辑
5. 同事们都因为要被裁员而不干活了，感觉多干了自己就吃亏了，其实我觉得吃亏的是自己，尤其是自己的声誉上，被领导贴上了不靠谱的标签。
以后领导再有好的机会可能就不会考虑这样的人了。我是觉得能干一天就要做一天的活，毕竟还领着公司的钱，而且自己也能被领导所看好，觉得
你比别人都靠谱。

---
## 2019年3月7日
1. c语言学习
```c
字符串的恒定性
大前提:是以字符指针形式存储的字符串。
1. 当我们以字符指针的形式存储字符串的时候，无论如何字符串数据都是存储在常量区中。
并且一旦存储到常量区中去，这个字符串数据就无法更改。
2. 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到
常量区，而是先检查常量区中是否有相同内容的字符串。
如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储在常量区。
3.当我们重新为字符指针初始化1个字符串的时候，并不是修改原来的字符串，而是重新创建了1个字符
串，把这个新的字符串的地址赋值给它。
4.容易混淆的地方
char *name = "jack";
name = "rose";
这样是可以的，只是在常量区新创建了一个rose字符串
char name[] = "jack";
name = "rose;
这样是不行的，因为name代表的是数组名称，不能为数组名赋值，可以使用下面的方式改变数组内容。
name[0] = 'r';
name[1] = 'o';

字符串数组
1. 使用一个二维字符数组来存储多个字符串，每一行都是一个字符串。
这个数组的每一行是1个长度为10的char一维数组。
但每1个字符串的长度不能超过列数减1，也就是9个
char name[][10] = 
{
   "jack","rose"
};
2.使用字符指针数组
char* name[4] = {"jack","rose"};
每个元素的类型是char指针,初始化给元素的字符串数据是存储在常量区的，元素中存储的是字符串在
常量区的地址。
使用这种方式的好处是每个字符串的长度无限制。

const关键字
用来修饰变量。一般情况下来说，变量具备一定程度上的不可变性。
1.const修饰基本数据类型的变量
const int num = 10;
int const num = 10;
这两种效果一样，都不能再次赋值
2.const修饰数组
const int arr = {10,20};
arr[0] = 100;这里是错的，元素不能修改
3.const修饰指针
int num = 10;
const int* p = &num;
*p = 20;//这里不能修改，报错
无法通过指针去修改指针指向的变量的值。但直接操作变量是可以修改的。
int num2 = 10;
*p = &num2;
但指针变量的值可以修改。可以把另外一个变量的地址赋值给这个指针。
int const *p1 = &num1;
效果同上
int * const p1 = &num;
int age = 20;
p1 = &age;//这里报错
*p1 = 100;//这里可以
int const * const p1 = &num;
这里什么都不可以改

const使用场景
1.const特点
被const修饰的变量是只读变量，只有取值不能改值。
2. 不允许别人去修改值的时候使用
3. 当函数的参数是一个指针的时候，函数的内部有可能会修改实参变量的值。
可以给函数的参数加一个const来修饰，这样函数内部就无法修改了，保证了数据的安全性。
void test(const int * num)
{

}


如何向堆区申请字节空间来使用
1. 我们在堆中申请的字节空间，如果我们不主动释放，那么系统是不会释放的，除非程序结束。
2. 在堆中申请字节空间的步骤
申请
使用
释放
3. 如何在堆区申请指定的字节数的字节空间呢
malloc()
calloc()
realloc()
这三个函数的声明在stdlib.h的系统头文件中。
4. malloc函数
int* p1 = malloc(4)
参数只有一个，是size_t类型也就是unsigned long。
作用是向堆空间申请指定字节的空间来使用。
参数代表的意义是，向堆内存申请多少个连续的字节空间。
返回值是void *，代表没有类型的指针。返回的是创建的空间中第一字节的地址。地址没有类型。
int* p1 = malloc(8);
p1操作的时候是以4个字节为基本单位。
5. 在堆区申请的空间是从低地址向高地址分配的。
且每次申请的字节地址都是从0开始的，每次申请的字节空间不一定是连续的。但是每次申请的指定个
字节，这些字节一定是连续的。
6. 在堆区申请的字节，里面是垃圾值，不会自动清0。
7. 在向堆区申请字节空间的时候，有可能会申请失败。如果申请失败返回的指针是NULL值。
我们申请完空间之后，最好是判断一下，是否申请成功。
int* p1 = malloc(12);
if(p1 != NULL)//判断申请成功
if(p1)//这样也可以判断申请成功
8. 申请完的空间一定要记得释放
free(指针);
free(p1);

calloc函数
优点是，申请完空间之后，系统会将字节中的数据清零。
calloc(size_t,size_t)
申请3个int类型的字节空间，也就是12个字节空间
int* p1 = calloc(3,sizeof(int));

realloc函数
作用是扩容，当我们发现我们之前在堆区申请的字节空间不够用的时候可以使用realloc函数
int *p1 = calloc(3,sizeof(int));
int *p2 = realloc(p1,4);
如果原来的空间后面还有剩余的空间，且足够扩容，则直接在后面的空间扩容。
不够的话重新找一块足够的空间，将原来的数据拷贝过来，原来的空间被自动释放。

指针与函数
1.指针作为函数的参数
在函数内部可以通过这个参数指针去修改实参变量的值

2.指针作为函数的返回值
下面是错误的代码
int* test()
{
  int arr[] = {10,20};
  return arr;
}
int* arr = text();
这样是错误的，因为test函数中的arr数组在test函数执行完成后被回收了，它是一个局部变量。
不能返回局部变量的地址。
如果要返回一个指针，要保证这个指针指向的空间在函数结束后仍然存在。
那么这个时候，就可以将空间申请在堆区，然后返回堆区的地址。一定要记得，调用者使用完了之
后一定要释放掉内存。
下面是改正后的代码
int* test()
{
  int* arr = calloc(3,sizeof(int));
  return arr;
}

如果函数的返回值是字符串，那返回值类型就是char*。
字符串常量存储在常量区里，可以直接返回这个字符串的地址，不用在堆区申请空间。
申请在常量区的空间是不会被回收的。
char* getWeekDay(int day)
{
  return "monday";
}
```
2. 修改运营平台国际版崩溃问题
3. 我们大组今天说明天晚上要去团建，我们组的人大部分都是要被裁员的，都没什么心情去。

---
## 2019年3月8日
1. c语言学习
```c
指向函数的指针
声明方式
返回值类型(*指针名)([参数列表]);
只能指向没有返回值，并且没有参数的函数。
void (*pFunction))();
int (*pFun)(int num1,int num2);
函数名代表函数的地址
void test(){}
void (*pFunction)() = test;
如何调用函数指针,下面两种方式都可以
pFunction（）
(*pFunction)()

结构体
struct 新类型名称
{

};
struct student
{
   int age;
   char* name;
};
上面只是声明了一个结构体类型，在使用时还需要再声明一个结构体变量。这个时候才会在内存中申请空间。
struct 新类型名称 变量名;
struct Student stu;
stu.name = "jack";
stu.age = 10;
匿名结构体
不可以再创建新的变量
struct
{
   int age;
   char* name;
} jeo;

结构体变量的初始化
1.先声明变量，再用.初始化
2.直接初始化，这种最常用
struct student lili = {"jack",20}
3.在声明结构体变量的同时，按顺序初始化部分成员
struct Student lili = {"li"};
4.指定成员初始化
struct Student jim = {.name = "ji",.age = 10};

结构体变量的成员的默认值
结构体变量的成员的默认值是垃圾值，只要在声明结构体变量的同时，只要初始
化1个成员，其它的成员都会被自动初始化为0

相同的结构体变量之间是可以相互赋值的，结构体之间赋值是值传递
struct Student jim = {.name = "ji",.age = 10};
struct Student li = jim;

结构体数组
元素类型 数组名[数组长度]
struct Student stu[5];
stu[0] = jim;
初始化方式
1.通过下标为结构体每个元素赋值
2.当我们为结构体数组的元素赋值的时候，如果直接使用大括弧来初始化，就必须
要在前面加个类型强转，告诉编译器我们要给的数据类型是结构体类型。
sut[0] = (struct Student){"qiao",12};
3.在声明结构体数组的同时，就给元素初始化。
struct Student stu[5] = {{"qiao",12}，{"jeo",12}};

结构体数组的长度计算
先使用sizeof计算出数组占用总的字节数，使用这个总字节数除以每1个元素占用的字节数。
int len = sizeof(stu) / sizeof(struct Student);

结构体指针
struct student lili = {"jack",20}
struct Student* pStu = &lili;
结构体指针访问结构体里的变量成员两种方式
(*pStu).name = "qqq";
pStu->name = "rose";

结构体嵌套
struct Date
{
  int year;
};
struct Person
{
  char* name;
  int age;
  struct Date birthday;
};
初始化
struct Person xiaoming = {"xiao",21,{1990}};

结构体作为函数的参数
结构体作为参数传值是值传递，除非传入的是结构体指针
void test(struct Student stu)
{
  
}
void test(struct Student* stu)
{
  
}

结构体作为函数的返回值
1.结构体类型可以作为返回值，
struct Student getStudent()
{
   struct Student s1 = {"qiao",21};
   return s1;
}
下面的代码是错误的，因为s1是局部变量，函数执行完成后就被销毁了。
struct Student * getStudent()
{
   struct Student s1 = {"qiao",21};
   return &s1;
}
如果要返回指针需要在堆内存中申请内存空间
struct Student * getStudent()
{
   struct Student *s1 = calloc(1,sizeof(struct Student));
   s1->name = "rose";
   return s1;
}

枚举
数据类型的变量的取值被限定
enum 新类型名称
{
   限定取值1，限定取值2，限定取值3
};
enum Dir
{
  East,
  South,
  West
};
表示新创建了1个数据类型，数据类型叫enum Dir

声明枚举类型变量
enum Dir dir;

注意
1.每一个枚举值都有一个对应的整形的数。默认从0开始，依次递增。
2.无论什么类型的枚举变量都占4个字节
3.枚举变量中真正存储的是枚举值对应的整型的数。
4.枚举值还可以重新赋值
enum Dir
{
  East = 10,
  South = 20,
  West =30
};

枚举使用规范
1.命名规范，首字母大写，每个单词的首字母大写。
2.枚举值的命名规范，枚举值的名称都以枚举类型来开头。

typedef
作用：为一个已经存在的数据类型取一个别名，如果我们想使用这个类型，直接使用这个别名
就可以了。
语法格式
typedef 已经存在的数据类型 别名;
typedef int qInt;
qInt num = 10;
经常使用的的size_t其实就是unsigned long，只是被取了别名而已
什么时候使用？
当数据类型很长的时候，就可以为这个数据类型取一个短一点的别名，这样使用方便。
unsigned long long int num =10;
typedef unsigned long long int hm;
hm num1 = 100;

为结构体使用typedef，声明一个短别名,分别有以下三种方式
第一种
struct student
{
   int age;
   char* name;
};
typedef struct Student stu;
第二种
typedef struct student
{
   int age;
   char* name;
} stu;
第三种
为匿名结构体使用typedef声名一个短名，最常用的方式

typedef struct
{
   int age;
   char* name;
} stu;
再使用的时候可以直接用下面的形式
stu s1;

使用typedef为枚举类型取一个短别名,两种方式
第一种
enum Direction
{
  East,
  South
};
typedef enum Direction Direction;
第二种
typedef enum Direction
{
  East,
  South
} Direction;

第三种
typedef enum
{
  East,
  South
} Direction;
直接使用
Direction dir = East;
```

---
## 2019年3月11日
1. c语言学习
```c
宏定义
它是一个预处理指令，所以它在编译之前执行。
可以为1段C代码定义一个标识
语法
#defing 宏名 宏值
#defing N 10
如何使用
在c代码中直接使用宏名就可以了
int a = N + 1;
宏的原理
在预编译的时候，就会执行源文件中的预处理指令
会将c代码中使用宏名的地方替换为宏值
在使用时要注意的地方
1.宏值可以是任意的东西，在定义的时候并不会检查语法
2.如果宏是一个表达式，使用时不会得到表达式的结果，而是直接替换为表达式
3.如果宏值如果有变量名，要保证使用前变量已经被定义
4.从定义宏的地方，后面的所有地方都可以直接使用，宏没有作用域
5.字符串中如果出现宏名，系统不会认为这是一个宏，而认为是字符串的一部分
6.宏的层层替换，
#define PI 3.14
#define R 3
#define AREA PI * R * R
AREA的宏值是3.14 * 3 * 3
doubel area = AREA;
7.如果定义宏的时候加了分号，宏值里会包括分号
解除宏指令
#undef N
作用
从解除宏指令之后的代码都不可以使用宏定义了

宏值带参数
#define N(a) a + a + a
int b = N(10);
宏代替的原理
1.先将传入的值传递给宏的参数，那么宏的参数的值就是我们传递的值
2.再把这个宏值当中使用的参数的地方换成参数的值
3.最后再将使用宏名的地方替换为最后的宏值

使用带参数的宏几点注意
1.宏不是函数，所以宏的参数不需要加类型，直接写参数名就行
2.在定义宏的时候，编译器是如何区别宏名和宏值的？
#define 空格 (中间的这块会当做宏名) 空格
所以在写宏的时候，空格要小心使用
3.为带参数的的传值是本色传递
int a = 10;
int b = N(a);
这里的N接收的只是a，并不是变量a的值，预编译期间得不到变量的值
4.宏值一旦换行就认为宏定义结束了，只有当代码很少的时候，才使用宏

条件编译指令
1.它是一个预处理指令，所以只能在预编译阶段执行。
2.作用
默认情况下，我们所有的C代码都会被编译为二进制代码，
条件编译指令的作用是可以让编译器只编译指定部分的代码。

用法
在预编译的时候，如果条件成立，就会将其中的C代码编译成二进制指令，
如果不成立，就不会将其中的c代码编译成二进制指令。

注意:
条件只能是宏，不能是变量
第一种用法
#if 条件
   c代码
#endif

示例
#define N 10
#if N = 10
printf("sdfasdf");
#endif

第二种用法
#if 条件
   C代码
#elif 条件
   C代码
#elif 条件
   C代码
#else
   C代码
#endif
其中#endif是必须要写的

第三种用法
如果定义了宏名，就编译其中的代码
#ifdef 宏名
   C代码
#endif

如果没有定义宏名，就编译其中的代码
#ifndef 宏名
   C代码
#endif

解决多文件使用#include被包含多次问题
#ifndef 宏名
#define 宏名 
  代码
#endif

static和extern
可以用来修饰变量和函数
1.修饰局部变量效果
static修饰局部变量
如果局部变量被static修饰，这个变量叫静态变量。
静态变量不再存储在栈区，而是存储的常量区
当函数执行完毕，这个变量不会被回收。
当再次执行局部变量时，声明静态变量这行代码会直接被跳过，不会再重复声明
实例
void test()
{
   static num = 1;//当函数第二次及以上被调用的时候，这行代码会被跳过
   num++;
}

2.修饰全局变量
当我们分模块开发的时候，如果要在模块中声明全局变量
1.全局变量的声明要写在.h文件中
2.全局变量的实现要写在.c文件中
3.如果将全局变量定义在模块中，这个全局变量就必须要使用static或者exter修饰
static和exter区别
使用extern修饰，这个模块中的全局变量就可以跨模块访问
使用static修饰，这个模块中的全局变量只能在当前模块中访问

static和extern修饰函数
static修饰的函数只能在当前模块中调用，无法跨模块调用
如果声明的函数没有用static修饰，那么它默认就是使用extern修饰的，可以跨模块调用

```
```oc
OC与C的不同
1.在c的基础上新增了1小部分面向对象语法
2.将c的复杂、繁琐的语法进行了封装，使用更为简单
3.oc完全兼容c语言
4.OC程序的源文件的后缀名是.m，m表示message，代表oc中最重要的1个机制，消息机制
5.#import指令
是一个预处理指令，是#include指令的增强版，将文件的内容的预编译的时候拷贝到指令的地方。
同一个文件无论#import多少次，只会包含1次。
原理:
底层会先判断这个文件是否被包含，如果被包含就会略过
6.框架
框架是一个功能的集合，苹果或者第三方事先将一些程序在开发程序时经常会用到的功能事先写好，
把这些功能封装在多个类或者函数之中，这些类和类的集合就叫框架，有点像c语言的函数库。
7.Foundation框架
这个框架提供了最基础的功能，输入和输出还有一些数据类型。
Foundation.h文件当中包含了Foundation框架中其它的所有的头文件
所以只要包含Foundation.h，就相当于包含了Foundation框架中所有的头文件。
那么Foundation框架中所有的函数和类就可以使用了。
8.@autoreleasepool是自动释放池
```
2. 今天被拘留的同事回来了，听说是因为打架的原因，感觉很不值当啊，但是有的时候就是脾气上来了，控制不了。
3. 组里有个同事异动去了别的组，然后另外一个同事也准备提离职的，还有一些人就等着被裁员，感觉组里的每个人都没有心思在这了
4. 今天把所有的c语言基本学完了，开始学习oc基础。在学习的过程中收获还是很大的，以前通过看书自学的时候，进度慢而且有些知识还看
不太明白理解不了，看视频学习感觉很多知识由老师一讲出来，感觉理解的很清楚，以前一些没明白的知识瞬间就明白了，也了解了程序运行
的一些原理，对自己之前学习的很多知识起到了一个串联的做用。看来学习C语言确实是对编程方面有很大帮助的。

---
## 2019年3月12日
1. oc语言学习
```oc
NSString
NSString类型是指针变量，专门用来存储OC字符串的地址。
OC字符串常量必须要使用1个前缀@符号
NSString *str = @"jack";
NSLog(str);//直接输出字符串
NSLog(@"大家好，我是%@",str);//使用%@来当占位符

NS前缀是什么
NextStep公司被评估收购，改名为Cocoa，被加入到Foundation框架中。
NS表示这个类是由NextStep公司写的。

@符号是什么
作用:
1.将c字符串转为oc字符串
2.OC中绝大部分关键字都是以@符号开头

OC程序的编译、链接、执行
1.在.m文件中写上OC源代码
2.使用编译器将源代码编译为目标文件
cc -c xx.m
3.链接
cc xx.o -framework Foundation
-framework Foundation是链接OC程序必须要加的，c语言不用加
如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉
编译器去哪个框架中找类。
4.链接成功后会生成一个a.out可执行文件

OC当中的数据类型
1.OC中支持C语言中的所有数据类型
2.BOOL类型
可以存储YES或者NO中的任意1个数据
一般情况用来存储条件表达式的结果
BOOL本质是
typedef signed char BOOL;
实际上BOOL类型的变量是1个有符号的char变量
#define YES((BOOL)1)
#define NO((BOOL)0)
平时开发主要使用BOOL
3.Boolean
可以存储true或者false
4.class类型 类类型
5.id类型 万能指针类型
6.nil 与NUll差不多
7.SEL 方法选择器
8.block 代码段

OC面向对象
类的声明
@inteface 类名 : NSObject
{
   //变量的声明写在这里
}
//方法的声明写在这里
@end

类的实现
@implementation 类名
//将方法的实现写在这里
@end

示例
@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
@end

@implementation Person

@end

注意点:
1.类必须要有声明和实现
2.类名的首字母要大写
3.变量必须要定义在@interface的大括号之中
4.变量名要用下划线开头

创建对象
对象的本质是一个C语言的结构体
语法：
类名 *对象名 = [类名 new];
Person *p1 = [Person new];

如何使用对象
访问对象属性
默认情况下，对象的属性是不允许被外界访问的，
如果允许对象属性可以被外界访问，那么在声明属性时要加一个@public
p1->_name = @"jack";//平时开发要使用->这种方式
p1->_age = 19;
(*p1)._name = @"jack";

OC的方法
示例
@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
方法的声明写这里
- (返回值)方法的名称;
- (返回值)方法的名称:(参数类型)形参名称;
- (返回值)方法的名称:(参数类型)形参名称1 :(参数类型)形参名称2;
@end

@implementation Person
方法的实现写这里
@end

@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
- (void)run;//声名一个无返回值无参数的方法
- (void)eatWith:(NSString *)foodName;//注意，方法的名字叫eatWith:,如果方法只有一个入参，方法名最好
加上With，这样易读性更好,是一种规范
- (int)sum:(int)num1 :(int)num2;//注意，方法的名字叫sum: :
- (int)sum:(int)num1 and:(int)num2;//注意，方法的名字叫sum: and:,加上and更加易读
@end

@implementation Person
- (void)run
{
   NSLog(@"fsdafdasf");
}
- (void)eatWith:(NSString *)foodName
{
    NSLog(@"fsdafdasf%@",foodName);
}
- (int)sum:(int)num1 :(int)num2
{
    return num1 + num2;
}
- (int)sum:(int)num1 and:(int)num2
{
    return num1 + num2;
}
@end

如何调用方法
[对象名 方法]
Person *p1 = [Person new];
[p1 run];//调用无入参的函数
[p1 eatWith:@"iii"];//调用有一个入参数的函数
int sum = [p1 sum:10 :20];
int sum = [p1 sum:10 and:20];

类的加载
在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的
代码段区域，这个过程叫做类加载。
只有类在第一次被访问的时候，才会做类加载，一个类只会被加载一次。直到程序
结束之后才会被释放。

对象在内存中究竟是如何存储的
Person *p1 = [Person new];
Person *p1;//会在栈内存中申请一块指针变量的空间
[Person new];//真正在内存中创建对象的其实是这句代码
new做的事情
1.在堆空间中申请1块合适大小的空间
2.在这个空间中根据类的模板创建对象，类模板中定义了什么属性，就把这些
属性依次的声明在对象之中，对象中还有另外一个属性叫做isa，是一个指针，
它指向对象所属的类在代码段中的地址
3.初始化对象的属性
如果属性的类型是基本数据类型，那么就赋值为0
如果属性的类型是C语言的指针类型，那么就赋值为NULL
如果属性的类型是OC的类指针类型，那么就赋值为nil
4.返回对象的地址

注意
1.对象中只有属性而没有方法。
2.如何调用方法
[指针名 方法名];
先根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类，
然后再调用类里的方法。
3.为什么不把方法存储在对象之中
因为每一个对象的方法代码实现都是一模一样的，没必要为每一个对象都保存1个
方法，太浪费空间，所以只把方法存储在代码段就可以了。

nil
只能作为指针变量的值。
nil其实也等价也0，也是一个宏。
nil与C语言的NULL是一样的，两个值相等。
虽然使用NULL的地方可以使用nil，但不建议这样做。

分组导航标记
主要是用来给代码文件添加一种特殊的注释用的，要结合Xcode使用
#pragma mark 分组名
会在导航条对应的位置显示1个标题
#pragma mark -
会在导航条对应的位置显示1条水平分隔线
#pragma mark - 分组名
会在导航条对应的位置显示1条水平分隔线，再显示标题

OC中注意点
1.属性名一定要以下划线开头
2.属性不允许在声明的时候初始化或赋值
3.如果方法只有声明没有实现，在调用时会报错
```
2.今天开始学习oc语言了，学习完c语言确实能更有助于学习oc的一些知识，主要是内存方面的更好理解，这样可以更好的使用内存和优化性能

---
## 2019年3月13日
1. oc学习
```oc
多文件开发
.h头文件写类的声明
.m文件写类和方法的实现

类的本质
类是我们自定义的一个数据类型
什么是数据类型：
是在内存中开辟空间的一个模板
声明一个函数，参数可以传入一个对象
- (void)test:(Dog *)dog;
声明一个返回对象的函数
- （Dog *)test;

异常捕获
C语言的异常无法捕获
避免异常最常用的方法还是用逻辑判断
@try
{

}
@catch(NSException *ex)
{

}
@finally
{

}

类方法
对象方法声明使用的是-号
- (void)test;
类方法声明用+号
+ (void)test1;
类方法的调用
可以直接使用类名来调用方法
[类名 方法名]

类方法的特点
类方法不用在堆申请空间，所以节约空间
类方法不用再通过指针找到堆中的对象的isa指针，而是直接代码区调用，效率高
类方法不可以使用成员变量，但可以在类方法里创建对象，使用对象的方法和变量
在对象方法中可以直接调用类方法

什么时候可以将方法定义为类方法？
如果方法不需要直接访问属性，也不需要直接调用其它的对象方法，
那么就可以定义类方法，提高效率

类方法的规范
1.如果我们写一个类，那么就要求为这个类提供一个和类名同名的类方法，
且这个方法创建一个这个类的对象作为返回值。跟java的构造方法很像。
也可以给这个方法传入一些参数，给对象的变量赋值。
2.方法名要写成 类名WithXXX: 这是苹果的规范
如：NSString *str = [NSString string];

NSString一些常用方法
将C语言字符串转换为OC字符串
stringWithUTF8String

拼接一个字符串对象，使用变量或者其它数据拼接成OC字符串
stringWithFormat

得到字符串长度，这个是对象方法
length

得到字符串中指定下标的字符
characterAtIndex
这个函数返回的数据类型是unichar，因为有些国家的文字字符要占一个字节以上，
所以不能用char来表示，要输出unichar变量的值，要使用%C

判断两个字符串内容是否相同
判断两个字符串不能用==判断，这样判断是不准确的
isEqualToString

比较字符串的大小
返回值可以使用int来接收
compare

匿名对象
没有任何指针指向这个对象，那么这个对象就是匿名对象
匿名对象只能使用1次，每次创建的都是不同的对象
如：
[Pserson new];
使用匿名对象的变量和方法
[Pserson new]->_name=@"jack";
[[Person new] sayHi];

setter和getter方法
只要属性需要被外界访问，就要为这个属性封装getter和setter方法，即使不
需要逻辑验证
setter声明和实现方式与java一样
getter的方法名命名与java不同，oc直接使用去掉下划线的变量名即可。

对象与对象之间的关系
组合关系
一个类中的变量是其它类的对象

依赖关系
一个类的方法入参是另一个类的对象，属于高耦合

关联关系
一个类作为另一个类的属性，但他们不是组合关系，而是拥有的关系

```

---
## 2019年3月14日
1. oc学习
```oc
static关键字
oc中static不能修饰属性和方法，可以修饰方法中的局部变量
它存储在常量区，方法执行完成后不会被回收。跟c语言一样，
只有第一次调用这个方法的时候这个static变量才会被声明，
第二次及以后调用这个方法不会再次被声明。
如果方法的返回值是当前类的对象，那么方法的返回值就写instancetype

self关键字
和java中的this有一点点像。oc的selt可以用在类方法中，但java不行。
可以在对象方法和类方法中使用，self是一个指针，在对象方法中self指向当前对象，
但类方法中只能调用类方法，对象的方法也不可以调用类方法。
在类方法中指向当前类。
类方法中的self指向代码段当中的类。
开发规范，对象的属性要求以下划线开头，局部变量不以下划线开头
对象方法和类方法可以重名
self->_name;
[self test];

继承
继承之后，子类具有父类中所有的成员
如果有一个成员，他不是所有子类都拥有，那么这个成员不应该定义在父类之中。
一个类只能有一个父类
A类从B类继承，c类从B类继承，那么C类拥有AB两个类的成员
子类不能再定义与父类重名的属性
父类的类方法也会被子类继承
@interface Chinese : Person

@end

@implementation Chinese

@end

NSObject类
所有的类必须都得继承NSObject类，这样做是有原因的
当我们创建一个对象的时候，通常的写法是
[Persion new];
这个其实是调用了NSObject类的new方法，然后这个方法的返回值是Persion类的
指针，如果不继承NSObject类就没有new方法，创建不了对象
同时isa指针也是NSObject类中的一个属性

super关键字
1.可以用在类方法和对象方法中
2.在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法。
[super test]
3.在子类的类方法中，可以使用super关键字调用父类的类方法。
4.super只能用来调用父类对象或类方法，不能用来访问属性

访问修饰符
修饰类的属性，不可以修饰方法

@private
只能在本类的内部访问

@protected
只能在本类和本类的子类中访问，如果不指定访问修饰符，
默认使用这种

@package
只可以在当前框架中访问

@public
可以在任意的地方访问

子类可以继承父类的私有属性，只不过子类中无法直接访问
从父类继承过来的私有属性。但如果父类中有一个方法在为
属性赋值或者取值，那么子类可以调用这个方法间接的访问父类
的属性

私有方法
只写实现不写声名就可以了，oc中并没有修饰符来修饰方法

多态
里氏替换原则
子类可以替换父类的位置，并且程序的功能不受影响
Person *p1 = [Studen new];
```
2. 今天晚上我们同事聚餐了，波哥去别的组了，我们组也有三个人也要走了，最后波哥说以后我们富贵相见，感觉还是挺伤感的，
挺好的一个组，说解散就解散了，现在大家没有得到确定要留下消息的人都等着被裁员拿补偿，没什么心思干活了。昨天新的组长也
跟我进行了谈话，说希望我能留下，也不会把我裁掉，我不知道今年会怎么样，只是好好把活干好吧，再就是多学点技术，争取把ios学会，
再把c++也学习下，把android系统的底层也学习下，然后后端这块也能学下，把前后端打通。

---
## 2019年3月15日
1. oc学习
```oc
里式替换原则的作用
1.一个指针中不仅可以存储本类对象的地址，还可以存储子类对象的地址。
2.如果一个数组的元素类型是一个oc指针类型的，那么这个数组中可以存储本
类对象还有子类对象
3.如果一个数组的元素是NSObject指针类型，它可以存储任意类型的对象指针
4.当一个父类指针指向一个子类对象的时候，只能通过这个父类指针调用子类对象中
的父类成员，不能调用子类特有的方法

重写
直接在子类的.m文件重写父类的方法就可以了

多态
同一个行为，对于不同的事物具有完全不同的表现形式

当我们使用%@打印一个对象的时候，NSLog函数调用的是
传入对象的description方法。
```

---
## 2019年3月18日
1. oc学习
```oc
代码段存储类的那块空间是个什么类型
在代码段中存储类的步骤
1.先在代码段里创建一个class对象
2.把对象的信息存到class对象里面，如类名、方法和属性、isa指针，
isa指针指向他的父类的类对象

如何拿到存储在代码段中的类对象
注意:
声明Class指针的时候，不需要加*，因为在typedef的时候已经加*了
两种获取类对象的方式
1.调用类的类方法claas，就可以得到存储类的类对象地址
Class c1 = [Person class];
2.调用对象的对象方法class就可以得到这个对象所属的类的Class对象的地址
Person *p1 = [Person new];
Class c2 = [p1 class];

如何使用类对象
1.c1等价于Person类
调用类方法
[c1 test];
2.可以使用类对象来调用new方法
Person *p2 = [c1 new];
注意
使用类对象，只能调用类的类方法，不能调用类对象的方法

SEL
全称叫做selector，是选择器的意思
SEL是一个数据类型，所以要在内存中申请空间存储数据
SEL其实是一个类。SEL对象是用来存储一个方法的
类是以Class对象的形式存储在代码段中的
类的方法存储在类对象之中的一个数组里，数组里的每个元素都是一个SEL对象，
将类中的每个方法都封装一个SEL对象
如何拿到SEL对象
因为SEL是一个typedef类型，在自定义的时候已经加*了，所以声明SEL指针的
时候不用加*了
SEL s1 = @selector(test);

调用方法的本质
[p1 sayHi];
内部原理
1.先拿到存储sayHi方法的SEL对象
2.p1对象接收到这个SEL消息以后，就知道要调用方法
3.根据对象的isa指针找到存储类的类对象
4.找到这个类对象以后，在这个类对象中云搜寻是否有和传入的SEL数据相匹配的，
如果有就执行，没有再找父类，直到NSObject类

OC最重要的一个机制，消息机制就是这个调用方法的本质，
调用方法的本质其实就是为对象发送SEL消息

手动为对象发送SEL消息
1.先得到方法的SEL消息
Person *p1 = [Person new];
SEL s1 = @selector(sayHi);
2.将这个SEL消息发送给p1对象
[p1 performSelector:s1];
3.调用一个对象的方法有两种
[对象名 方法名];//常用
手机的为对象发送SEL消息

注意事项
1.如果方法有参数，那么方法名是要带上冒号的
2.还要传递参数
[p1 performSelector:s1 withObject:@"qqq"];
3.如果有多个参数
Params *ps = [Params new];
SEL s1 = @selector(testWith:);
[p1 performSelector:s1 withObject:ps];

点语法原理
p1.age = 18;
这句话本质并不是直接赋值给p1对象的_age属性，
点语法在编译器编译的时候，会将点语法转换为调用setter、getter代码
注意
1.在getter和setter中慎用点语法，因为有可能会造成无限递归
如
self.age;
2.点语法在编译器编译的时候，会转换为调用setter和getter方法的代码，
如果我们的setter方法和getter方法名不符合规范的话，那么点语法就只会出问题
3.如果属性没有封装getter和setter是无法使用点语法的

@property
声明一个类的时候总要为他的一些属性写上setter和getter方法，
我们可以使用@property来标识属性，这样会自动生成setter和getter方法
要写在.h文件里的属性下面
例如:
@interface Person : NSObject
{
   int _age;
}

@property int age;//这里不要加下划线

@end

使用注意
1.@property的类型和属性的类型一致因为这个决定着生成的getter和setter方法的返回值类型
2.@property的名称要去掉下划线，因为这个决定着生成的getter和setter方法的名字
3.@property只是生成getter和setter方法的声明，实现还要自己来写

@synthesize
作用:自动生成getter、setter方法的实现，所以应该写在类的实现之中,
但这样会新生成一个新的私有属性
语法:
@synthesize 属性名称;//注意不要加下划线
例如:
@implmentation Person

@synthesize age;//注意不要加下划线
@end

如果希望@synthesize不要自动生成私有属性的getter和setter方法，
而且是直接操作我们已经定义好的属性，就需要换一种写法
如下
@synthesize age = _age;

以上的@property和@synthesize是Xcode4.4以前的写法，从4.4以后
对@property做了一个增强
4.4以后只需要写一个@property编译器就会自动生成getter和setter方法,
如果需要在setter或getter做逻辑判断，直接重写这两个方法就可以，但
不能同时重写，会报错

id指针
是一个万能指针，可以指向任何oc的对象
id id1 = [Person new];
[id1 sayHi];//不用类型转换直接调用Persion里的方法

NSObject和id的异同
相同点:都是万能指针，都可以指向任意的oc对象
不同点:
通过NSObject指针去调用对象方法的时候，编译器会做编译检查。
通过id类型的指针去调用对象方法的时候，编译器直接通过。

注意点：
id指针只能调用对象方法，但不能使用点语法

instancetype
如果方法的返回值是instancetype,代表方法返回的是当前调用这个方法的对象。
使用建议
1.如果方法内部是创建当前类的对象，不要写死成[类名 new]
而是要用self代替类名，写成[self new]
2.如果方法返回值是当前类的对象，也不要写死成当前类名，而是要写instancetype

id和instancetype的区别
1.instancetyep只能作为方法返回值，不能在别的地方使用，
id可以声明指针变量，也可以作为参数，也可以作为返回值。
2.instacetype是一个有类型的，代表当前类的对象
id是一个无类型的指针，仅仅是一个地址，没有类型的指针。
```
2. 波哥今天就正式搬到那边了，中午也变成了我自己吃饭，还有一点点不太适应，哈哈，其实我是想去健身的，只是自己去
没意思

---
## 2019年3月19日
1. oc语言
```oc
构造方法
new方法的内部，其实是先调用alloc方法，再调用init方法
alloc方法是一个类方法，作用是创建调用方法的类的对象，并返回对象
init方法是一个对象方法，作用是初始化对象,为对象属性赋初始值，
这个init方法我们叫构造方法
虽然没有初始化的对象有时候也可以使用，但这样做是非常危险的。
Person *p1 = [Person new];
等价于
Person *p1 = [[Person alloc] init];

我们每次通过上面的方式创建对象时属性都是默认值，如果我们想不是属性为
默认值时，可以重写init方法
重写init方法的规范
1.必须先调用父类的init方法，然后将方法的返回值赋值给self
2.调用init方法初始化对象有可能失败，如果初始化失败，返回的就是nil
3.判断父类是否初始化成功，判断self的值是否为nil,如果不是则初始化成功
4.如果初始化成功，就初始化当前对象的属性
5.最后返回self
两种写法
- (instancetype)int
{
   self = [super init];
   if(self != nil)
   {
      self.name = @"jack";
   }
   return self;
}

- (instancetype)int
{
   if(self = [super init])
   {
      self.name = @"jack";
   }
   return self;
}
解惑
1.为什么要调用父类的init方法
因为父类的init方法会初始化父类的属性，如isa指针等，所以必须要保证当前
对象中的父类属性也被初始化
2.为什么要赋值给self
因为调用父类的init方法，会返回初始化成功的对象，实际上返回的就是当前对象。
但我们要判断是否初始化成功。

重写init方法的不足
每次创建出来的对象属性的值都是固定写死的
这时可以自定义构造方法
规范
1.自定义构造方法是返回值必须是initancetype
2.自定义构造方法的名称必须以initWith开头,因为self不能在initWith开头的方法外使用
3.方法的实现和init的要求一样

调用的时候要先调用alloc方法来创建对象，再调用初始化方法
如
Person *p = [[Person alloc] initWithName:@"小明" andAge:19];

内存管理
引用记数器
每一个对象都有一个属性，叫retainCount，引用记数器。类型是unsigned long占8个字节。
用来记录当前这个对象有多少个人在使用它。
如何操作引用计数器
1.为对象发送一条retain消息，引用计数就会加1
2.为对象发送一条release消息，对象的引用计数就会减1
3.为对象发送一条retainCount消息，就可以去查到引用计数器的值
当对象的计数器变为0的时候，对象就会被回收，
对象被回收的时候，就自动调用对象的dealloc方法

内存管理分类
MRC:手动引用计数，手动管理内存管理,要使用手动管理要先关闭ARC模式
需要程序员手动的发送retain和relase消息
ARC:自动引用计数，自动内存管理
系统自动的在合适的地方发送retain和relase消息

内存管理原则
1.有对象创建，要匹配一个release
2.retain的次数要和release的次数要匹配
3.谁用谁retain，谁不用谁release
4.只有在多一个人用的时候才retain，少一个人使用的时候才release
5.手动管理内存如果重写了dealloc方法时，要在dealloc方法的最后一行
调用父类的dealloc方法才行
如
[super dealloc];

野指针
在C语言中，定义一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，
指向一块随机空间，这个指针就叫野指针
在OC语言中，指针指向的对象已经被回收了，这样的指针叫野指针。

僵尸对象
一个已经被释放的对象，但是这个对象所占的空间还没有分配给别人，这样的
被叫做僵尸对象
打开僵尸对象检测功能，是极其损耗性能的，所以一般默认是关闭的
僵尸对象是无法被复活的

内存泄露
指的是一个对象没有被及时回收，一直驻留在内存中

单个对象的内存泄露
1.有对象的创建，没有对应的relase
2.retain的次数和relase的次数不匹配
3.在不适当的时候为指针赋值为nil
4.在方法中为传入的对象进行不适当的retain

如何保证单个对象可以被回收
1.有对象的创建，就必须要匹配一个relase
2.retain次数和release次数一定要匹配
3.只有在指针称为野指针的时候才赋值为nil
4.在方法中不要随意为传入的对象retain

当一个类的属性是一个oc对象的时候，setter方法写的方法，将
传进来的对象赋值给当前对象的属性，代表传入的对象多了一个人使用，
所以我们应该先为这个传入的对象发送一条retain消息，然后再赋值，
当当前对象销毁的时候，代表属性指向的对象少一个人使用，就应该在
dealloc中使用relase方法进行减少引用次数
代码写法
- (void)setCar:(Car *)car//注意，目前这个写法是有问题的，下面有改进方式
{
   _car = [car retain];
}
- (void)dealloc
{
  [_car release];
  [super dealloc];
}

当属性是一个OC对象的时候，setter照上面写还是有bug的，
当为这个属性多次赋值的时候，会产生内存泄露，
发生泄露的原因：
当为属性赋值的时候，代表旧对象少一个人用，新对象多一个
人用，应该先relase旧的对象，然后retain新的对象
改造后代码,其实这样写还是会有bug，如多次调用该方法入参car是同一个对象时
会出问题
- (void)setCar:(Car *)car
{
   [_car release];
   _car = [car retain];
}

解决上面问题的方案
当发现新旧是同一个对象的时候，什么都不用做，
只有新旧不是同一个对象的时候，才release旧的，retain新的
改进后代码
- (void)setCar:(Car *)car
{
   if(_car != car)
   {
      [_car release];
      _car = [car retain];
   }
}
- (void)dealloc
{
   [_car release];
   [super dealloc];
}
只有需要内存管理的oc对象属性才需要上面那种写法，普通的变量类型不用

@property生成setter和getter方法
它生成的setter方法的实现当中，无论是什么数据类型的，都是直接赋值的，
在MRC中如果属性是对象类型的话是不可以用的，需要自己重写

@propterty是可以带参数的
@property(参数1，参数2，参数3....)数据类型 名称;

@property的四组参数
a.与多线程相关的参数
atomic、nonatomic
b.与生成的setter方法的实现相关的参数
assign、retain
c.与生成只读、读写相关的参数
readonly、readwrite
d.是与生成的getter和setter方法名字相关的参数
getter、setter

与多线程相关的参数
atomic:默认值，这个时候生成的setter的代码就会被加上
线程安全锁，安全但效率低
nonatomic:这个时候生成的setter的代码就不会加上线程安全
锁，不安全但效率高，建议使用这种
```

---
## 2019年3月20日
1. 今天空域app开始测试了，有一个同事家里有事请长假回家了，还有一个同中要离职，他俩的bug目前都需要我来解，他俩的Bug
真是多啊，忙活一天，没办法学习oc了
2. 添加解析空域bean，修改json bean错误
3. 修改飞服师列表页时间错误
4. 修改编辑页执照为空错误
5. 修改首页开启围栏崩溃
6. 修改用户中心去掉计划入口
7. 修改我的机型列表为倒序排列
8. 修改无人机列表文本超出问题

---
## 2019年3月21日
1. 添加飞服师上传图片逻辑
2. 修改无人机列表型号错误
3. 解决资质认证界面解析错误问题
4. 修改添加飞服师成功后不返回列表页问题
5. 修改上传图片bug
6. 修改添加飞服师空类型判断
7. 修改多次点击提交按钮无反应
8. 修改编辑飞服师图片不显示问题
9. 修改证书不显示问题
10. 修改飞服师列表时间格式错误
11. 修改添加批件方案提示错误
12. 修改个人用户信息页显示方案错误
13. 修改日期控件默认展示开始日期
```oc
与生成的setter方法的实现相关的参数
assign:默认值，生成setter方法的实现就是直接赋值
retain:生成的setter方法的实现就是标准的MRC内存管理代码，先判断
新旧对象是否为同一个对象，如果不是release旧的
当属性类型是OC类型的时候，使用retain
当属性的类型不是OC类型的时候，使用assign
但是要注意，retain参数只是生成标准的setter方法为MRC内存管理代码，
不会在对象的delloc方法中生成relase代码，所以我们必须要手动的在dealloc中使用
release方法

与生成只读读写的封装
readwrite：默认值，代表同时生成getter和setter
readonly:只会生成getter

生成getter、setter方法名称相关的参数
默认情况下@property生成的getter和setter生成的是标准的名称，
但可以使用setter和getter入参来改生成方法的名称
一般情况下我们是不使用setter和getter来改名字的，但当属性是BOOL类型
的时候，可以修改这个getter的名字开头以is开头，提高代码可读性。

关于@class
当两个类互相包含的时候，会出现循环引用的问题，造成无限递归问题，导致
无法编译通过
解决方案
其中一边不要使用#import引入对方的头文件，而是使用@class来标注这个类，
这样就可以解决这个问题，还要在.m中使用#import引用对方法的头文件就可以有
代码提示了

@class与#import的区别
1.#import是将指定的文件内容拷贝到写指令的地方
2.@class不会拷贝内容，只是告诉编译器这是一个类

当两个对象相互引用的时候，A对象的属性是B,B对象的属性是A对象，这个时候
如果两边都使用retain那么就会发生内存泄露，谁都无法释放谁
如何解决
一端使用retain，另一端使用assign，使用assign的那一端在dealloc中不再需要
release了

自动释放池
存入到自动释放池中的对象，在自动释放池被销毁的时候，会自动调用存储在
自动释放池中的所有对象的release方法
这样就不再需要手动的去调用对象的release方法了
@autoreleasepool
{

}

```

---
## 2019年3月22日
1. 今天突然让写一个5g项目的招标文件，以前从来没接触过这个东西，刚看到跟天书一样，各种没见过的名词，
让往里写很内容感觉是根本不可能完成的事。不过还好，在网上找了一堆东西拼了上去，只是不知道能不能合格，
实在是不会写这个东西，应该找更专业的人来写啊，毕竟这个是很重要的东西。下周一周的时间都要用来写这个，
希望能赶紧写完吧。
2. 听说有的部门已经开始996了，我们这基本上算是995吧，不知道什么时候也要变成996。我们的工位也换了，
搬到了16层，我的位置还行，比想象中好点吧，但没有18层那么好，换了环境感觉像是换了一份工作一样。身边的
同事各种请假，周四、周五和周末两天一连上真爽啊。不知道他们是去面试了还是怎样。

---
## 2019年3月25日
1. 状态不好，看了一点oc视频，不过知识基本都会

---
## 2019年3月26日
1. oc学习
```oc
分类
在创建一个类文件的时候，会有一个File Type的选项，这里面要选Category类型，
才可以创建分类的文件
1.将一个类分为多个模块，其实就是给一个类添加新的方法，这样可以
在不改变以前的类文件的情况下做到
2.如何为一个类添加分类
跟创建普通的类一样，只是多一个分类名在类名的后面，用括号包含.
分类并不是创建一个新类，而是对已有的类添加一个分类。一个类可以
有多个分类，所以每个分类要有自己的名字。
3.会生成一个.h和一个.m的模块
模块文件名是:
本类名+分类名.h
本类名+分类名.m
4.添加的分类也分为声明和实现
@interface 本类名 (分类名)

@end

@implementation Student (itcase)

@end
5.分类的使用
如果要访问分类中定义的成员或方法，就要把分类的头文件引进来

使用分类要注意的几个地方
1.分类只能增加方法，不能增加属性
2.在分类之中可以写@property，但是不会自动生成私有属性，也不会
自动生成getter和setter的实现，只会生成getter和setter的声明。
3.在分类的方法实现中不可以直接访问分类的私有属性，但可以调用
本类的getter和setter方法来访问属性。
4.当分类中有和本类中同名的方法的时候，优先调用分类的方法，哪怕
没有引入分类的头文件。如果多个分类中有相同的方法，优先调用最后
编译的分类。

非正式协议
非正式协议是给系统自带的类定义分类

ARC机制和垃圾回收机制的区别
GC：
程序运行的期间，垃圾回收器不断的扫描堆区进行垃圾回收。
ARC
是在程序编译的时候，就把释放对象的语句写的代码中了。

类的一类构造方法初始化属性时要注意的点
下面是错误代码
- (instancetype)initWithCar:(Car *)car
{
   if(sele = [super init])
   {
      _car = car;//错误写法
   }
   return self;
}

- (void)dealloc
{
   [_car release];
   [super dealloc];
}
当使用_car = car;赋值的时候，并没有调用对象的retain方法，这样
对象的引用数不会加1，当外部释放对象引用的时候，会造成僵尸对象，
car方法已经被释放掉了
应改为
- (instancetype)initWithCar:(Car *)car
{
   if(sele = [super init])
   {
      self._car = car;//这里改成这种写法
   }
   return self;
}

- (void)dealloc
{
   [_car release];
   [super dealloc];
}
当我们使用self._car = car;进行赋值的时候，
self.car会自动调用当前类的setter方法，这样
setter方法使用@propety时，会自动调用car对象的
retain方法，进行引用数加一，这时就不会出错了。

延展(Extension)
在创建一个类文件的时候，会有一个File Type的选项，这里面要选Extension类型
延展是一个特殊的分类
特殊之处:
a.延展没有分类名字
b.只有声明没有实现，只有一个.h文件，并且和本类共享一个实现
c.延展当中可以加属性，@property会自动生成getter和setter的声明和实现
延展语法
@interface 本类名 ()

@end

什么时候使用延展
当我们想要为类定义私有成员的时候，就可以使用延展，将延展定义在类的实现
文件中。
如果想要为类写一个私有属性，虽然我们可以定义在@implementation之中，但
不要这么写，因为不规范。我们需要写一个延展，将私有属性定义在延展中。
如果要为类写一个私有方法，建议将声明写在延展中，实现写在本类的实现中，
这样可以提高代码的可读性。
如果想要为类写一个私有的@property属性，就直接写在延展里就可以了。

block
block是一个数据类型。是用来存储一段代码的。这段代码可以有参数，
可以有返回值。但并不是任意一段代码都可以存进去的，而是有限定的。
语法格式
返回值类型 (^block变量的名称)(参数列表);
void (^myBlock1)();
int (^myBlock2)();
int (^myBlock3)(int num1,int num2);

初始化block变量
格式：
^返回值类型(参数列表){
     代码段;
};
^void(){
   NSLog(@"opop");
};
可以将这段代码使用赋值符号存储到无返回值无参数要求的block变量中。
两种赋值方式
void (^myBlock1)();
myBlock1 = ^void(){
    NSLog(@"ljkljklj");
};

void (^myBlock1)() = ^void(){
    NSLog(@"ljkljklj");
};

有返回值的代码段
int (^myBlock2)() = ^int(){
    int num = 10 + 20;
    return num;
};

既有参数又有返回值的
int (^myBlock3)(int num1,int num2) = ^int(int num1,int num2){
     return num1 + num2;
};

如何执行代码段变量中的代码
myBlock1();
int i = myBlock(10,20);

关于block简写
1.如果我们写的代码段没有返回值,void可以不写
void (^myBlock1)() = ^(){
   NSLog(@"fdfsf");
};
2.如果代码段没有参数，小括号也可以不写
void (^myBlock1)() = ^{
   NSLog(@"fdfsf");
};
int (^myBlock1)() = ^int{
   NSLog(@"fdfsf");
   return 1;
};
3.声明block变量的时候，如果有指定参数，可以只写参数类型而
不写参数名称
int (^myBlock3)(int,int) = ^int(int num1,int num2){
     return num1 + num2;
};
4.无论代码段是否有返回值，在写代码的时候，可以不写返回值类型。
如果在写代码段的时候，省略的返回值，这个时候系统会自动确定返回值
类型。
但建议不要简写。
int (^myBlock3)(int,int) = ^(int num1,int num2){
     return num1 + num2;
};

使用typedef简化block定义
typedef void (^NewType)();
NewType block1;
NewType block2;
typedef int (^NewType2)(int num1,int num2);
NewType2 t1 = ^int(int num1,int num2){
   return 1;
};
```

---
## 2019年3月27日
1. oc学习
```oc 
关于block块访问外部变量的问题
1.在block代码块的内部可以取定义在外部的变量的值，定义在外部的局部变量和全局变量。
2.在block代码块的内部可以修改全局变量的值，但不能修改定义在外部的局部变量的值
3.如果你希望我们定义的局部变量可以允许在block代码的内部去修改，那么就为这个局部变量前
面加一个__block的修饰符。

block作为函数的参数
两种写法
void test(void (^block1)())
{
    block1();
}

tyepdef void (^NewType)();
void test(void (NewType block1)
{
    block1();
}

如何调用test方法
两种方式
NewType type = ^{
   NSLog(@"fsdfdsaf");
};
test(type);

test(^{
   NSLog(@"fsdfdsaf");
});

block也可以做为函数的返回值

协议(Protocol)
作用
1.专门用来声明一大堆方法的
2.只要某个类遵守这个协议，就相当于拥有这个协议的所有方法。
3.协议中只能声明方法，不能定义属性，也没有方法的实现
4.一个类只能有一个父类，但可以有多个协议
5.类的名称可以和协议的名称相同
语法
@interface 类名 : 父类名 <协议名>

@end

@interface Dog : NSObject <MyProtocol>

@end

@interface Dog : NSObject <MyProtocol,YouProtocol>

@end

修饰协议的两个修饰符
@required
在协议中，如果方法是被@required修饰，那么遵守这个协议的类必须要实现这个方法，
否则编译器会发出警告，默认是@required
@optional
如果方法是被@optional修饰,那么遵守这个协议的类可以实现这个方法，也可以不实现这个方法，
不实现编译器也不会报警告

协议可以从另外一个协议继续
子协议不仅有自己的方法声明，还包含父协议的方法声明
语法
@protocol SportProtolcol <FProtocol>

@end

```
2. 今天凌晨，我最喜欢的游戏之一要出新内容了，好激动呀，不过由于明天要上班所以就不能第一时间玩上了
3. 上午学习了一下关于gradle方面的知识

---
## 2019年3月28日
1. oc学习
```oc
协议类型的限制
声明一个指针，可以指向任意对象，但要求指向的对象要遵守指定的协议。
NSObject<协议名称> *指针名;
这个时候，这个指针可以指向遵守了指定协议的任意对象，否则会报一个警告。
如果一个指针有多个协议，那么指针指向的对象也要同时遵守多个协议。

Foundation框架常用类
NSString
字符串的内容是不可变的，如果给字符串指针变量重新赋值的时候，
其实是重新指向了一个新的字符串常量。
当两个字符串指针变量所指向的字符串内容一样时，其实两个指针指向
的地址是一样的。
存储在常量区的字符串是不会被回收的。
//这种方式声明字符串，字符串的值是存在常量区中的
NSString *str1 = @"jack";
//这种方式声明字符串，字符串的值是存在堆中的
NSString *str2 = [NSString new];
//将字符串内容写到文件中
writeToFile
参数1:写入到的文件路径
参数2:YSE，先将内容写到一个临时文件，如果写入成功再把文件搬到指定的目录。
NO,直接将内容写入到指定文件，这个不安全，但是效率高，一般使用此种方法。
参数3:指定写入的编码
参数4:二级指针，要传递一个NSError指针的地址。如果写入成功，这个指针的值
是一个nil，如果写入失败，指针指向一个对象，描述了发生错误的信息，
这个对象的localizedDescription方法可以得到发生错误的信息。
返回值是BOOL，代表是否写入成功。

从磁盘上的文件读取文件内容
+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:
(NSStringEncoding)enc error:(NSError **)error;

NSURL
作用：
既可以读写本地文件，也可以读写网页文件、ftp服务器上的文件
不同的类型的URL地址的写法
1.本地磁盘文件：file:///User/aa/1.txt
2.网页地址:http://www.itcase.cn/index.html
3.ftp文件的地址:ftp://server.itcase.con/1.txt
将不同类型地址封装在NSURL对象之中
NSURL *u1 = [NSURL URLWithString:@"http://www.itcase.cn/index.html"];
//读取文件内容
NSString *str = [NSString stringWithContentsOfURL:u1 
encoding:NSUTF8StringEncoding error:nil];
//写入文件内容
NSString *str @"dfasf";
BOOL res = [str writeToURL:u1 atomically:NO encoding:NSUTF8StringEncoding error:nil];

判断字符串是否以指定的字符串开头
- (BOOL)hasPrefix:(NSString *)str;
判断字符串是否以指定字符串结尾
hasSuffix

在字符串中搜索子串
返回值NSRange是一个结构体，里面有两个属性。
location:代表子串在主串中的第一次出现的下标，没有找到此值为NSUInteger的最大值，
也等于NSNotFound
length代表子串在主串中匹配的长度，如果没有匹配到此值是0
-(NSRange)rangeOfString

截取字符串
从指定的下标处一直截取到最后
substringFromIndex
NSString *newstr = [str substringFromIndex:3]
从第0个开始截取指定的个数
substringToIndex
截取自定义的范围
substringWithRange

字符串替换
//这个方法会替换字符串里所有相同的字符
stringByReplacingOccurrencesOfString

NSMutableString
使字符串具备可变性，可以更改字符串
不可以使用下面的方式进行初始化
NSMutableString *str = @"fdsf";

NSArray
1.是Foundation框架的一个类，具备数组的功能
2.只能存储OC对象
3.长度固定，一旦NSArray创建完成，长度不可改变，无法新增和删除元素
4.元素的类型是id类型
5.将元素写完以后，最后要写一个nil，表示数组结束
6.如果数组的中间元素有一个nil，后面的元素都会失效
常用的初始化方法
第一种方式
arrayWithObjects
第二种方式，简要的方式，这种方式不需要在最后加nil
NSArray *arr = @[@"jack",@"rose"];
当NSArray里存的元素类型不一致时，可以使用id来遍历
```

---
## 2019年3月29日
1. oc学习
```oc
NSMutableArray
是NSArray的子类，但他是可以新增元素和删除元素的，是一个可变的数组。
注意点
NSMutableArray不可以使用下面的方法初始化
NSMutableArray *arr = @[@"dfsa",@"fdf"];

NSNumber
OC定义的封装基本类型值的一个对象，主要是为了可以把int值存入到
NSArray里使用。
NSArray *arr = @[@10,@20,@30];
上面的代码，@10代表一个NSNumber对象，这个对象包装的是整形的10。
也可以把变量的int赋值给NSNumber
int num = 10;
NSNumber *n1 = @(num);

NSDictionary
NSMutableDictionary
这们是数组，但是以键值对的形式存储数据的。
键只能是遵守了NSCoping协议

NSDictionary下面这种初始化方法，是值在前，键在后
NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@"jack",@"name",@"北京市",@"address,nil"];
简要创建方式，这种是键在前，值在后
NSDictionary *dict = @{@"name":@"rose",@"age":@"18"};
遍历的话要使用for in的方式来遍历
item键，通过item来取值
for(id item in dict)
{
  dict[item];
}
还可以使用blcok的方式遍历
[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key,id _Nonnull obj,  
BOOL * _Noonull stop){
   
}];

NSMutableDictionary不能使用下面的方式初始化，要使用
dictionartWithObjectsAndKeys方法初始化
NSMutableDictionary *dict = @{@"":@"",@"":@""};
新增键值对
调用setObject方法，这个是值在前键在后
也可以将字典数组持久化
writeToFile
dictionaryWithContentsOfFile

在MRC的模式下，将一个对象存储到集合中，会为这个对象的引用计数器+1。
当集合销毁的时候，就会向存储在集合中的所有对象发送一个release消息。
在ARC的模式下，集合的元素是一个强类型的指针。

NSFileManager是Foundation框架提供的一个类，
可以用这个类操作磁盘上的文件、文件夹，对它们进行删除、移动、复制、拷贝、创建

CGPoint
是一个结构体，是用来表示ios控件在界面上的坐标。
快速创建一个CGPoint对象
CGPoint p1 = CGPointMake(20,30);

CGSize
用来表示一个控件的大小，宽度和高度。

CGRect和NSRect
这个结构的作用是用来存储一个控件的位置和大小。

NSValue
这个类的作用是用来包装一些无法存储到NSArray数组中的结构体的。

NSDate
时间日期的处理
```
2. 今天是3月份的最后一天，oc基础也差不多快要学完了，下周开始准备做ios的小项目，熟悉下生命周期和一些控件。
3. 早上刚来，我们组的几个同事都被叫出去聊了要被裁员的事情，最后组里剩不下几个人，感觉还是挺凄凉的。看来还是要不断的提高自己
的技术水平，这样就不怕在经济寒冬的时候被裁员而找不到工作。

---
## 2019年4月1日
1. 今天是宝宝的生日，时间过的真快，一年的时候转眼就过去了，希望五年后会有新的变化，越过越好。
2. oc学习，今天就把oc全部的视频课程看完了，下一步要开始真正的ios开发了，学习ios方面的知识。
```oc
字符串的copy
无论在MRC还是ARC，如果属性的类型是NSString，@property参数要使用copy。
copy是一个方法，定义在NSObject类之中，作用是拷贝对象。
NSSttring使用copy没有产生新对象，而是直接将对象本身的地址返回，这种
拷贝我们叫浅拷贝。
NSMutableString调用copy方法，会产生一个新的对象，这种叫深拷贝。但
返回的是一个不可变的对象(NSString对象)。
mutableCopy，是定义在NSObject中的方法，是深拷贝，返回的是一个可变的
字符串对象。
字符串对象拷贝的引用计数器问题
1.若字符串对象存储在常量区中，存储在常量区的数据是不允许被回收的，
所以存储在常量区的字符串对象的引用计数器是一个超大数，并且retain
和release无效。
2.若字符串存储在堆区，这个字符串对象和普通的对象一样的，引用计数器
默认是1.
3.字符串对象如果是浅拷贝，会将对象的引用计数器加1
字符串对象如果是深拷贝，原来的对象的引用计数器不变，新拷贝出来的对象
的引用计数器为1.

对象拷贝
1.copy方法是内部调用了另一个叫copyWithZone方法，
这个方法是定义在NSCoping协议中的，如果我们自己定义的类没有遵守NSCoping
协议，调用copy方法就会报错
2.自己创建的类要遵守NSCoping协议，还要重写copyWithZone方法
//深拷贝实现方法
- (id)copyWithZone:(NSZone *)zone
{
  Person *p1 = [Person new];
  p1.name = _name;
  return p1;
}
//浅拷贝
- (id)copyWithZone:(NSZone *)zone
{
  
  return self;
}
```
---
## 2019年4月2日
1. 学了一天的ios控件，包括看书和看视频，有点走出了舒适区的感觉，什么都不会，从头摸索学习新知识，是会感觉会不舒服，
但这样才能使自己进步，相信会越来越适应，克服这种不适感。入门的话看书的效率确实低一些，有些书写的并不是很明白，看视频
人家一讲就明白了。

---
## 2019年4月8日
1. 回老家休息了四天，姑娘一岁了，感觉比过年看到她时聪明不少，现在知道主要要吃的和她不喜欢做的事会哭了。感觉每天除了看孩子
就是睡觉，时间过的很快，好像只在家待了一天就回来了。
2. 修改消息页UI
3. 添加无人机上传图片功能
4. 添加提交无人机数据判断逻辑
5. 修改无网络时提交图片接口报错
6. 修改软键盘类型错误问题

---
## 2019年4月9日
1. 通过视频学习了ios的界面开发，使用tableView开发简单的列表样式。自己手动跟着视频课程做了一次，还需要多多复习啊，刚开始做很生疏，
做的很慢，后面多做做应该就好了。学习了三种界面开发的方式。

---
## 2019年4月10日
1. 今天学习ios学的有点灰心，可能是进步不明显再加上热情期过了吧，再就是有一点动摇的原因是感觉出去找工作学这个似乎用不太上，
应该把数据结构或者安卓啥的东西再精进一下。不过我当初学ios是为了学flutter的时候可以更好的理解两端融合，还有就是做ios的同事
如果离职了如果有ios我可以做。我还是要坚持学，不然前期学的c和oc都白费了，继续努力坚持。
2. 今天确定小宝宝这个月不过来北京了，因为她去到人多的地方就会不适应，会哭的很厉害，一冬天没有出门，冷不丁一出门会害怕。最近天暖和了，
多带她出去转转，看看秋天能不能来吧。

---
## 2019年4月11日
1. 突然得知我们组最后只能留下3个人了，感觉好凄凉。心情很低落，做什么都没有心情了。虽然我是留下的人，但我却非常的焦虑，无所适从的感觉。
不知道未来会怎样。

---
## 2019年4月12日
1. 最近组里发生了重大变化，学习方向上又有点迷茫了。因为我们组要散了，现在面临有可能要得新找工作的问题，我最近又在学习ios，感觉在面试中
这个似乎并没有什么帮助，所以在想要不要学习点有面试帮助的，比如算法啥的。

---
## 2019年4月15日
1. 迷上了怪物猎人....

---
## 2019年4月19日
1. 这周状态很差，晚上睡不着，白天困的头疼，眼睛也酸涩的难受。这周也开始跑步了，希望状态能好点。

---
## 2019年4月22日
1. 眼睛难受的睁不开，头也疼，一天基本没干什么。晚上回家敷个面膜好好睡一下。

---
## 2019年4月23日
1. 为了有可能要准备面试，还是决定学习下算法方面的知识，想先从基本的学起，然后做一个笔记复习用。因为每次学完了过后都忘了，
后面如果忘了看笔记会很快的想起来。
2. 学习了快速排序，二分查找，选择排序，学习了下大O算法的知识
3. 看了三道剑指offer里的算法题，其中有一个稍微难一点的题也理解了，感觉还不错。
4. 现在感觉如果出去面试，好像唯一我差一些的就是算法和数据结构方面的东西，工作方面的焦虑更多的是技术上没有什么方向，所以
想着急的学很多东西，但技术这个东西又不是很快能速成的，尤其是一些基础的知识。昨天看到一句话，说如果感觉焦虑什么，就去做，
做的过程中焦虑就会慢慢的减少了，所以我决定了，目前为了有可能要出去面试，我要先学好算法和数据结构。这次再找工作，一定要
找个更好的。

---
## 2019年4月24日
1. 把昨天学习的算法做了一个脑图，还把代码实现都手写和敲代码弄了三遍，感觉理解更深入了。
2. 看了下算法图解这本书，把二分查找、选择排序、快速排序又学了一遍。

---
## 2019年4月25日
1. 今天学习了下字符串匹配的kmp算法，这是一个很复杂的算法，看了一天，算是学会了60%的算法思路，后面准备把代码实现也弄下。

---
## 2019年5月5日
1. 五一假期结束了，在牡丹江看了四天孩子，感觉不错，这次走又要有很长一段时间看不到她了，很想她。一家人在一起的感觉真的很好，这才是
真正的福报吧。五一前波哥给推荐了一个内部安全的岗位，由于hr要求最少在京东工作时长两年以上才行，没有给我面试的机会，有点可惜，其实我挺
想去这个组的，安全算是技术的一个比较不错的方向，比做业务好多了，有的时候一个机会真的可以改变人的一生。后来又电话面试了一个汽车部门，
我感觉80%我答的都不错吧，可惜有几个确实答的不好，人家没要我，这块我要着重的再看下，希望可以下次面试成功。去年好不容易进入了京东，我
还是挺想留下来的，而且要是换了工作还要搬家，住燕郊在北京上班真是不行，每天睡觉太少，最近两年我感觉自己老了很多，白头发和皱纹多了不少。
6月份之前，必须要好好刷面试题了，不管最后能不能留在京东，都要做最坏的打算。

---
## 2019年5月6日
1. 看了下之前面试没有答好的题，尤其是插件化和热修复，最近要开始查漏补缺。
2. 又投了一个简历，石沉大海了....不过晚上快下班时来了意外惊喜，波哥又给我推了一个异动，是我们这层的，跟我目前是一个大组的，说要
明天面试下，希望能成功。

---
## 2019年5月7日
1. 今天看了一天面试题，主要是看了下Picasso的源码实现，还有BufferKnife的实现原理和注解方面的，这两块上次被问到没有答好，看的脑袋有点疼。
本来约好要下午3点半面试的，结果因为有事，被往后拖了，现在5点10了，还没开始....
2. 我们组要被裁员的同事昨天已经被谈完了，下周五就都要走了，我们组就剩下我和组长两个人，感觉好凄凉....我要尽量赶到组长的前面异动，要不就会有
点尴尬。被裁的同事没被裁的时候都期望着赶紧被裁，然后得到补偿，等真正这天到的来的时候，又会有点留恋这里，其实我们组挺好的，只是大组不行，
公司在钱的方面真的支持的很到位，可惜啊，我感觉是管理层不行导致的失败，其它组的领导根本就是来混日子的，没有真正想把这个事情做好，要不也
不至于弄到现在这样，半死不活的状态。
3. 媳妇没有怀孕，真不错，哈哈。
4. 今天看Picasso源码时发现了Volatile关键字，这个之前学习过，有点记不清了，刚又学习了一次，有过眼熟学习的就是快。

---
## 2019年5月8日
1. 上午跟面试的部门聊了下，就简单的问了我两个关于flutter的问题，其它的都是我问他们部门的一些问题。感觉他们组挺忙的，995常态。反正先保住
工作吧，以后有机会还是要转波哥那边，看看做一下纯技术的工作。

---
## 2019年5月9日
1. 今天又看到了以前的一个android技术专家的博客，他写了一篇关于android开发人员今后发展方向的问题。其实我最近这两年是比较迷茫的，一直在
做业务层的开发，岗位非常依赖业务的好坏，而且在技术的提升方面基本上算是没有了，天天写一样的代码，年轻人分分钟就能代替，所以我这几年也是
比较焦虑这块，害怕失业，主要是想有一个技术方向，一直去深挖学习，然后成为某个方向的专家，感觉这样才能一直靠技术吃饭，不然就会被裁，毕竟
年轻人比你能加班，身体比你抗造，而且工资还低。
目前是有一个方向，也是波哥推荐的一块，就是flutter。其实这个我有一点担忧，就是不知道这个技术能活多久....所以有点不太敢全力把精力放在这块。
现在他那边在全力做这个，如果能去他那边我还是会努力去做的。

---
## 2019年5月10日
1. 今天下午，面试那个组的组长说不要我了，他们想找一个级别更高的人过来，没想到晚上11点半了，又给我打电话说想周一面试我看看，真是柳暗花明啊，
看看周一怎么样吧。

---
## 2019年5月13日
1. 下午跟面试的部门组长聊了一个小时，感觉他好像比较想让我过去，他说还要再跟领导反馈下看看。他跟我说他们那边加班很多，问我能不能抗得住，
其实现在我能有个部门去就不错了，不管怎样都要接受啊。最近经济越来越不好，很多互联网公司的效益也降下来很多，非常多的公司开始让员工拼命的
加班，可能认为这样公司才能存活下去，最近也频繁听到有员工抗不住加班倒下的事件，这种工作环境被更多的人所默默接受，好多公司也变本加厉的，
不知道什么时候才能改变这样的氛围。

---
## 2019年5月14日
1. 下午又跟部门hr和一个架构师聊了下，主要跟我沟通的就是加班问，算是给我打了一个预防针，说这边加班特别多，问我能不能接受不了，还有家里状况的
问题，生活跟工作是没办法平衡的，只能顾一头。反正我现在能有一个地方工作就行吧，再找工作也是这样。不过我以为会让我下周才去这个部门，没想到让我
明天就去。
2. 刚沟通完，就给我分来了工作内容....是要修改一个界面的UI和逻辑，看起来很简单，其实我阅读过代码之后发现逻辑还是很复杂的，要改的很多，而且还不
能把原有的代码改动太大，这样会引起其它的bug，下班前把项目的编译环境弄好了，明天开始正式开发。

---
## 2019年5月15日
1. 今天松海给我说了下要改动的代码部分，周一就要用这块的功能，如果周五做不完周末又要来加班，希望我赶快做好吧，周末真是不想过来，最近要9105或者
9106了。
2. 今天把UI和逻辑改动部分基本上是改完了，明天就剩下查漏和改bug了。其实我觉得我做的还是挺快的，代码不熟，业务不熟，一天就改好，也就是我了，哈哈。

---
## 2019年5月16日
1. 今天是我们组被裁员同事上班的最后一天，有一个同事送给了我8本书，要走的人其实我觉得还是不好受的，毕竟不是自己想要走，而是不得不走。现在出去
找工作技术一般确实不太好找，这两年是到了经济衰退的时候，编程人才的缺口已经差不多没了，技术不过硬基本很难找到工作。之前的几家公司，最先离职的
都是我，从来没有见过别人离职，这次是见识到了，我们组16人，明天就剩2个人了，我心里还是挺不舒服的，不管怎样，希望大家以后都好吧。

---
## 2019年5月17日
1. 终于赶在周末前把工作都做完了，做的过程中不断发现新问题，然后解决，虽然当时说的是只加两个小功能，但并没有那么容易，希望周末没有什么问题，我
真的不想来公司了....这周四天，天天工作11个小时以上，真的不行了。
2. 今天晚上没想到是新来的这个组的团建日，去了一个轰趴馆，挺小的，也没啥玩的....吃了一顿火锅，吃了好多肉，还有同事带着电脑去，吃完了还要
项目上线，真是不容易啊，这边活是真多。
3. 被裁的同事彻底走光了，我们组就剩下两个人啦，下周我也要搬到新的组了，希望今年能好一点，至少能涨下工资....好好表现吧。

---
## 2019年5月20日
1. 周末又发现了一个适配问题，还好没其它大问题，早上来就给改好了。
2. 晚上项目上线了，这次比较顺利，上的功能也不大，所以上完线就下班了，不过也是晚上10点半了....

## 2019年5月21日
1. 把人员多选这块做完了
2. 弄了下要分享的ppt
3. 今天没有加班，回去好好休息
4. 下午参加了一个新项目的需求评审会，有一块大的需求要用flutter来做，不过要是我一个人做只给4周时间我感觉根本不够，不知道后面会怎么
安排这块
5. 新来的这个组负责的项目是真的多啊，平均一个人要负责三个项目才行...

## 2019年5月22日
1. 发现编辑选择多个人员这块有个后端的bug
2. 今天被分到了备件库项目的一些需求，界面比较简单，下周二或周三做好，下午熟悉了下项目代码，然后写了一个界面UI

## 2019年5月23日
1. 完成了三个界面开发，明天开始写点接口逻辑
2. 公司正好有小龙虾促销，我买了两盒，周末准备买瓶啤酒放松下
3. 这两天一直在想着以后要回东北的问题，我一想到赚钱变少了，工作也不稳定就很害怕。反正明后年看看沈阳和大连吧，今天看了下招聘信息还是
有一些的。

## 2019年5月27日
1. 完成了商家出单界面的接口和逻辑
2. 晚上做了关于flutter的分享
3. 今天又看了西安的房价，有点小心凉啊，我买的小区又降价了，真的怕过几年贷款还完了，但是房子降价了好多，最后发现这几年白干了。

## 2019年5月28日
1. 把制单的三个界面逻辑和接口写完了
2. 今天换了新的合同，跟之前同事的合同不一样，心里有一点点不爽...可是没办法，只能签。

## 2019年5月29日
1. 今天下班又跑了五公里，发现这一个月我只跑了四次，相当于一周一次的水平，不过今天跑的速度明显比之前要快了，体力比以前要好
2. 今天把移库建单的两个界面都做完了，还有一个界面的逻辑就全部完事，这周五肯定能做完，然后下周会有新的项目要开发，继续使用flutter。
其实这次多亏了我会flutter才能异动成功，这个组就缺会使用flutter的人。我也算运气好吧，正好之前的项目使用的这个，感谢波哥啊，这个技术
是他强制我们使用的，然后我们才去学习。

## 2019年5月30日
1. 移库上架接口联调和逻辑开发
2. 晚上松海请我们去吃烧烤聚餐，好久没吃烧烤了，再就是好久没去麦家小馆了。之前去是3年前在京东到家的时候组里一起聚餐的时候去的，
这次再去感慨时间过的很快，这几年发生了很多变化。没想到刚来无人机这边就赶上了换组，不知未来会怎样。

## 2019年5月31日
1. 今天把仓储这边所有的需求都开发完成了，这个月也过去了，明天6月1，好希望在家能陪陪老婆孩子。

## 2019年6月1日
1. 昨天晚上突然被安排今天来值班，貌似是因为今天要来的同事要陪孩子过6月1，我也好想陪孩子过6月1啊

## 2019年6月3日
1. 周末就休息了一天，今天上班感觉好累呀，最近晚上有点失眠，躺床上好久才能睡着。

## 2019年6月4日
1. 今天跑了5.5公里，本来要提测结果没提，一天没什么活，算是休息了一天吧。好消息是这周只上四天班，坏消息是周日又要过来值班。

## 2019年6月5日
1. 把选择车牌号的控件做了

## 2019年6月6日
1. 明天端午节了，本来可以休息三天，结果因为618要来值班，只能休息两天了。
2. 媳妇说想下周末去大连玩两天，可是有点纠结花钱多，又不太想去，其实出来转转也挺好，毕竟在家憋了那么久。
3. 最近我也在看沈阳的房子，想着以后不行就去沈阳生活吧，全款买个房子生活压力小点。

## 2019年6月9日
1. 这几天忙的都忘写工作日志了....
2. 今天来值班，一天没有发生什么事，干坐了一天，毕竟没发生什么事也是好的，只是真的学不进去，想看书，看会就看不进去了

## 2019年6月10日
1. 从今天起要开始做一个新的flutter功能，要新开一个插件项目，第一次做这种插件项目，有好多东西要学习
2. 这周先把界面都做完，然后下周开始弄逻辑和调用接口部分。
3. 今天把项目整体框架搭建起来了，但是在引用包这块出现了问题，看了一天也没有解决，明天得开始做界面了，这块要先放一放，不能一直阻塞在这

## 2019年6月11日
1. 修改目录结构，添加派车单界面
2. 添加选择车型列表UI,添加提交按钮和界面滑动
3. 修改创建派车单界面UI

## 2019年6月12日
1. 添加现场派车界面，修改提交按钮为圆角
2. 添加运输任务明细页
3. 添加派单查询列表页
4. 添加派车明细列表页
5. 今天的效率还是很高的，目前只差一个界面UI部分就写完了，比我预想的速度要快，最让我担心的就是网络请求和逻辑处理那块，我想要抽取出来
公用的部分，但目前在依赖库这块还是有问题

## 2019年6月13日
1. 今天下午有两个人要来面试的，主要是做flutter这块，松海说希望以后这块我来主导做开发，我面临了不小的挑战啊.....

## 2019年6月14日
1. flutter的framworks工程弄完了

## 2019年6月15日
1. 早上到了大连，见到了孩子与媳妇，真的很高兴，在大连玩了两天，还吃了海鲜烧烤。

## 2019年6月17日
1. 修改编译失败问题，添加framworks依赖
2. 修改类分组，添加网络请求基类
3. 添加派车明细接口和逻辑

## 2019年6月18日
1. 去一线仓库支援了一天，这次我选了另外一个仓库，虽然位置偏一点，但干起来一点不累，一是有好的工具，二是人多。

## 2019年6月19日
1. 添加派车单查询接口和逻辑
2. 添加驳回派单接口和逻辑，修改bloc拼写，添加搜索逻辑
3. 添加运输任务列表接口和逻辑
4. 添加搜索派车任务逻辑，添加筛选条件判空
5. 添加运输任务接口
6. 添加现场派车驳回接口和逻辑
7. 修改toast，添加创建派车单接口和逻辑
8. 添加编辑派车单逻辑

## 2019年6月20日
1. 修改派车页等加载数据
2. 修改派车列表界面加载逻辑
3. 添加派车详情页接口和逻辑
4. 添加现场派车界面逻辑
5. 添加省份接口，修改appid
6. 添加派车页加载更入参逻辑
7. 修改筛选code没有赋值问题
8. 修改创建派车单逻辑
9. 修改派车列表解析逻辑，修改创建派车逻辑
10. 添加获取车型列表接口和逻辑，添加派车列表解析code列表逻辑

## 2019年6月21日
1. 添加时间戳解析
2. 添加运输详情页接口逻辑
3. 添加派车列表页驳回接口逻辑
4. 添加派车单页加载更多逻辑
5. 修改派车单创建成功逻辑，修改派车详情页体积显示问题
6. 修改派车单列表页加载更多逻辑
7. 修改派车列表搜索框text类型
8. 添加派车单查询列表接口逻辑和加载更多逻辑
9. 添加派车单详情页接口和逻辑
10. 修改编辑派车单逻辑
11. 添加创建派车单获取车型列表逻辑和接口
12. 添加编辑派车获取车型逻辑
13. 超级忙的一周，每天要写10个小时代码，累死我了。支援那天算是休息了吧，但是要拼命工作补回来，感觉好疲惫，每天下班
脑袋都是木木的状态，什么都不想想，也不想说话。今天总算忙完了，要不周末还得过来，真是受不了这样。其实是我是喜欢写
代码的，但一天写超过4个小时就变成了折磨。

## 2019年6月24日
1. 今天终于把剩下的两个接口弄完，缺的逻辑和bug也都补上了

## 2019年6月25日
1. 弄了一天集成和打包的问题，每次打包都要删除根目录下的build文件，不然有可能新代码不能加载进来。

## 2019年6月26日
1. 开始做新的功能模块，与推送相关，今天把界面做完了
2. 有点嗓子疼和流鼻涕，可能要感冒....

## 2019年6月27日
1. 得知要把消息存到数据库，然后把greenDao加了进来，这块要重新熟悉一下，之前用过，所以还好
2. 根据UI设置把界面又细调了一下
3. 今天面试了一个人，主要是flutter方向，这个人总体感觉技术还可以，是一个小公司技术总监，年纪也不大。面过他之面，我有了
一点点压力，感觉一个人能会的很多技术真好啊，虽然最后他没通过，主要是iOS部分，我们同事感觉这块能力有点欠缺。

## 2019年6月28日
1. 今天把greenDao数据库逻辑部分都弄完了，界面的逻辑也弄完了，周末可以不用来加班，每周最大的期盼就是周末，我感觉这样很不好，
不是一种健康的节奏，没有更多的时间学习技术，天天就是赶业务代码的上线，我现在再出去找工作，经验要写7年，感觉其实我跟3年的人差距
不大，所以心里很焦虑。

## 2019年7月8日
1. 最近忙的要死啊，每日记录都忘写了，每天基本都10点下班，敲8个小时代码，周六也来加了一天班，周日在家也写了一下午代码，
头一次感觉休息和上班差不多。突然觉得有点干够了，想去个二线城市算了，可惜我还有房贷要还，要不就走了....
2. 从这周开始要做一个新项目，时间非常紧张，只有两周时间。周末我做了很多UI界面，基本把设计出的界面都做完了。
3. 晚上11点到家，写代码写的10个手指头都麻了

## 2019年7月9日
1. 上周五下班的时候，我们大组开了个会，我们大组被拆分了，我们小组被分到了另一个组，新的领导我还不认识，不知道以后会怎么样。
自从我来京东，就安稳了半年，之后一直处于动荡之中....
2. 今天开始做结算列表的逻辑了，万幸的是使用的加载更多的框架是好使的。

## 2019年7月10日
1. 上周末去了口腔医院，本来想镶牙，但医生说我这是最后面的一颗牙，没办法镶牙只能种牙，这一下又要花出去一万块钱，感觉这个月白干了...
2. 心里一直有个痛处放不开，就是西安的房子。说实话，我感觉当时确实有点买急了，没有再多看看，也是因为当时的形势给弄的心态不稳，总是
感觉西安房价要短时间涨起来很多，这次不抓紧买又会像杭州一样，一下1万8变成2万5，就买不起了。只是希望不要跌，只要保持住这个价位就好
3. Flutter的开发速度确实要比原生快很多，我算是提前一点时间完成了任务

## 2019年7月11日
1. 设计出的Ui图我基本都做完了，根据接口文档也把界面的逻辑也写了一半多，下周开始要完善下细节部分。
2. 今天新组长给我们开了个周会，说了下他带领团队的风格和管理的一些东西，感觉新组长还可以，不过我们做前端的在这边确实不是很受重视，
我已经经历过一次组织变动，所以还是知道如果不是受重视的组以后好多晋升和加薪都不会优先考虑，过完年我还是要多看看机会吧。

## 2019年7月12日
1. 终于到了周五，可惜我明天还要来上班
2. 新组长说下个月会找机会放我一个小长假，不知道能否实现。最近真的挺累的，不是身体累是脑和心累，对什么事都提不起什么欲望和兴趣，就想
待着放空下。

## 2019年7月13日
1. 来加班一天，做了一些关于任务列表方面的东西，实在是干不动了。

## 2019年7月14日
1. 今天上午去口腔医院检查了种牙方面的问题，选择最便宜的材料全部算下来也要花1万1，这个月真是白干了，越是需要钱的时候越要花钱，
真是难受。本来打算10月份把姑姑们的钱还上，还完了又要回到解放前，重新开始攒钱了。下一步就准备把房贷欠的50万还上，然后找个城市
抓紧买房定居，不知道什么时候能定居。

## 2019年7月15日
1. 添加任务列表接口
2. 添加tabBar图片，修改任务列表时钟图片
3. 修改任务列表数据获取字段
4. 添加历史任务列表界面
5. 修改结算列表结算状态逻辑
6. 修改确认运费按钮显示状态

## 2019年7月16日
1. 今天意外得知了我们组所有人的级别情况，没想到我们组其它同事级别并没有我想的那么高，甚至有些人比我还低一些....
2. 修改未中标价格显示字段
3. 添加确认运费接口
4. 添加中标列表价格
5. 修改显示金额字段，修改appId
6. 添加没有任务的时候可以跳转找货列表逻辑
7. 最近加班有点多，在寝室的群里也跟他们说了下，确实感觉很累，终于知道之前有些加班多的人为什么脾气不好了。自从来了
这个组，一直很忙，github的更新也变得草草了事，很多都是后期补上的，感觉这样并不好，以后我会再来看这些日志的，会从这些文字里
回想起我当时工作的情景，如果记录的不好，会感觉有记忆上的缺失。

## 2019年7月17日
1. 媳妇跟我说最近晚上孩子醒的很频繁，导致她睡不好觉，头疼的很厉害，今天早上去检查了，下午才出结果，希望她没有事。

## 2019年7月26日
1. 最近真的是太忙了，每天都10以后下班，每天忙的头疼。周末要去种牙，又要花一万多块钱，很心疼啊，一年就12个月，花了这钱
相当于有一个月没有赚到钱。
2. 最近一直在想去青岛工作安居的问题，发现青岛房价确实太高了，去了的话又要欠那么多房贷，感觉不太合适，看来只能在沈阳或大连，
其实我感觉大连都有点悬，房价也是那么贵。

## 2019年7月29日
1. 周六加了一天班，周日把牙给种上了，真是没想到出奇的顺利，刚开始我还非常紧张，都有点喘不上气。医生说我的骨头挺多的，不用种骨了，
直接种牙，一下就省了3700，感觉真好，而且种完了也没有疼痛感。
2. 今天开始提测了，目前感觉Bug应该不是很多，希望最近能稍微轻松些。

## 2019年8月1日
1. 今天加了一个在沈阳东软工作的人微信，大概问了下那边的情况，感觉就是赚死工资的地，也没什么好跳槽的公司，去一个地方基本就稳定在那里了，
不知道我明后年去的时候会什么样。沈阳最近这一年房价也涨起来了，感觉能涨到1万5左右吧。
2. 周末玩了下尼尔机械纪元，感觉剧情还是挺不错的，音乐也好听，好久没玩到剧情这么优秀的游戏了。

## 2019年8月5日
1. 终于休息了一个周末，上周五测试完事，结果又来了UI和交互要改，真的好麻烦。

## 2019年8月9日
1. 这周连改Bug带Ui走查，还要改交互优化，忙活了一周，下周又要开始新的版本开发了，不知道要忙活多久才行....
2. 前几天听同事说了他之前的同事去沈阳工作的情况，感觉很不好啊，其实主要是目前经济大环境就不好，北京好多公司都存活不下来，
别说其它城市的it公司了。而且沈阳的房价一直在涨，而我在西安买的房子确又不涨了。看看怎么办法，感觉能去的城市越来越少了。

## 2019年8月21日
1. 最近太忙了，忙的每天都没来这记录。最近忙的心情也不好，就感觉又回到了那种成为螺丝钉的状态，天天只是繁忙的写同样的代码，一点
进步没有，有外面面试的机会感觉都面不上。最近我也帮别的组面试了几个人，感觉技术好的确实不多，可能最近来面试的都是剩下那些技术不好
的人吧，技术好的人基本都在公司上班呢.....
2. 有一个滑动的功能实现不了，昨天晚上也是担心的没太睡好，今天来了，找到一个方法能解决一半的问题，但另外一半就没有办法了，看看
明天说一下交互能不能接受吧。
3. 上周跟组长说了下想9月中秋节之后休五天年假，虽然同意了，但感觉有点勉强....不知道到时能不能真休上，车票我已经抢完了。
4. 上周末在家休息，发现没有什么游戏想玩了，干什么都提不起兴趣，不知道是最近加班太多的原因还是什么。
5. 前两天看了下烟台和秦皇岛的工作，房价还可以，就是工作机会太少，其实我挺想去这两个城市的，可惜没什么我的工作。

## 2019年8月30日
1. 又到周五了，这个月也剩最后一天了，感觉从五月末到这边后，时间过的挺慢的。三个月的时间，感觉过了能有至少半年那么长，可能是因为加班太
多导致的吧，把加班时长加起来，每个月会至少多上四天班以上。
2. 忙起来之后一直把更新日志这里疏忽了，像极了当年在汽车之家的感觉，每天忙的要死，但一点学技术却学不到，成为了一个熟练的螺丝钉，有一种
随时能被取代的感觉。昨天也跟波哥聊了一些，有些事确实想不到，也身不由己。想去外面看看机会，但离职的理由又是什么呢，只是活多重复学不到东西
这个理由吗？我这些年也跳了几次槽，但大部分都比较失败，所以我有点轻易不敢再跳了，如果再跳，我总是想要因为点什么或是我要追求点什么，至少一个
最大的原因是我想学到更多技术，能让自己能力变强，不容易被取代那种。要不总是感觉活的很焦虑，不知道未来会怎样。

## 2019年9月4日
1. 这几个杂活多，算是不太忙的一周吧。不过还要做个通用控件，比我相像的要复杂些，因为总想着要给别人用，怎么用着舒服，怎么用着简单、合理，这方面
考虑了很多，还有通用性，因为思考这个，改了好几次，总算是越改越好，算是完成了70%了。还有两个是另外两个同事做的，那个是真复杂啊。

## 2019年9月6日
1. 周五了，今天晚上公司组织去团建，去北京周边的一个地方，今天晚上出发，明天上午看三个景点下午就回北京，感觉一点意思没有，折腾一趟浪费了宝贵
的休息时间.....还好我可以不去，上次去的地方，听同事说晚上饭都没吃饱，明天好好休息，下周再干四天就回牡丹江了。
2. 下周开始又接了一个大活，一个项目要重新做，听说改动非常大，看看给我分的啥活吧，看来又一轮疯狂加班要来了。
3. 上周跟波哥聊了下工作的事，他其实挺想把Flutter这块做好的，可惜现在的领导不重视这个，也不给他分配人一起做，他还是有点力不从心啊。
不过好处是可以研究自己喜欢的技术，可以提高自己，还是挺好的。希望我也有机会做这样的工作....

## 2019年9月24日
1. 从9月13日一直休息到了9月22日，上周请了五天假，跟中秋节连上了，在牡丹江待了10天，头一次休这么长时间的假期，感觉还是不错的，不过感觉
时间过很快，好像只休了三、四天就回来了。在家一直看孩子，跟孩子稍微熟悉些了，然后我就又走了....看看十月一能不能回去，现在还没有抢到票，
回去了还能待七天。
2. 今天之前组的同事要离职，晚上请我们吃饭聚个餐，不知道都有谁会去。时间过的真快啊，眼看着这一年又要过去了，我收获了什么，我也不知道，感觉
每天过的懵懵的，就是忙忙忙。
3. 下个月就能把欠姑姑的十万块钱还上了，然后就开始真正的给自己攒钱了，希望接下来能顺利些，少出点花钱的事情，争取早日把房贷还完，然后房子能卖个
好价格，能去上大连。
4. 昨天回到公司就开始解决bug，还好bug不多，也比较好解决，算是挺顺利了，休假也没有影响工作。接下来又有新的功能要开发，今天把所有要做的需求
评审完了，又要开始新的一轮忙碌啦。

## 2019年9月25日
1. 昨天晚上跟之前的同事聚餐，感觉大家都在吐槽公司的不好，都不想在这干了。但是我觉得，真觉得不好走就是了，光吐槽有啥用呢，还不是外面的找不到
所以走不了，只能在这图个嘴快。还有个被裁员的同事，去了网易，感觉他就是特意过来跟我们显摆的，说自己那边不加班如何如何好。显然是过来酸别人的，
你看我虽然当时是被裁员了，但我走了之后更好了，还在那里鼓动别人也离职，我也真是无语。就感觉这种聚会的氛围就变了，我们在一起不是为了聚会，真
的挺没意思。
2. 今天评估完了工时，不知道会不会被砍些，明天开始正式干活吧。还好有几个不太好做的需求因为不合理被砍掉了....也算给我降低了开发难度。

## 2019年9月27日
1. 明天本来余睿要聚餐的，他婚礼我没去上，这次在北京说要聚下，结果他们公司临时发邮件说明天他们要上班，然后国庆多休一天就改为节后回来聚了。
2. 十月一回家的票到现在也没抢到，感觉有点回不去了....没想到这次十月一这么火爆，我这是第一次没抢到票，希望这几天能抢到吧。
3. 最近找到了单机版的dnf很是激动，前天晚上弄了下终于成功运行起来了。听着熟悉的音乐感觉自己又回到了大学，当时玩这个我还是花了不少钱，
现在想想感觉真是浪费，那个时候家里给的压岁钱我都花在了这个上面。在临沂上班时，发的第一个月工资，花了600买了一个戒指...后来我不玩了，
800又给卖了。现在玩的这个好了，想要什么直接就可以获取到，不用再花钱了，也算能完成我当时玩好游戏的梦想吧。

## 2019年9月30日
1. 昨天抢到了10月1日回牡丹江的票，可惜30号晚上出发的没有抢到，这样就白白浪费了一天休息时间在路上，回北京的票还没有抢到，感觉也是有点悬啊。
要是7号票买不到只能买6号的，但这样我就不太合适了，本来我就晚回家一天，这样又早走一天，在家就没待几天，唉。
2. 今天打算在公司住一晚上，然后明天直接从公司出发去北京南站了，一想到晚上要住在公司，还有一点点害怕，因为晚上整个楼层就我一个人，我把自己的
电脑带来了，希望玩累了就睡，明天一早起来就完事。
3. 发现这周有一件大事我没有记录，程哥给我年中涨薪了1千块钱，我是头一次呀，这个是很不容易的，因为名额少，程哥决定给我一个名额，也是看我在flutter
这块做的不错，我之前做的司机app他和领导都比较满意，所以给了我这次的名额，希望我以后好好努力，争取年后回来再加薪一次。这次加薪算是把我最近
来回的火车票钱给补上了吧，这个月真是花销有点大，听媳妇说这个月基本没攒下钱。下个月中旬，不出什么意外的话，就可以把欠我姑姑们的10万元钱还上了，
终于除了银行我不欠别人钱了，希望两年后我可以攒到40万，把银行房贷的钱还上，这样我今后的日子就会好过一些，不敢想象没有房贷的日子啊。

## 2019年10月8日
1. 节前在公司睡了一晚上，真是难受啊。没想到会这样，熬到2点多也睡不着，躺在行军床上一点也不舒服，翻身都没法翻，一个人在一个上百平米的大平层里
感觉很不舒服，半夜还有蚊子，咬了我好几个大包，以后再也不想睡公司了。
2. 在家待5天，抢回北京的票抢的很悬，差点没抢到，提前了一天回到北京，感觉这5天过的挺慢的，比上次10天过的慢，跟宝宝玩了这几天感觉很好，走的时候
没有遗憾，感觉自己尽了最大努力且用了所有时间跟宝宝相处，虽然她还是跟我不是很亲，但也很好了。这两次休假感觉自己涨了快10斤，肚子又变大了，脸上肉
也多了，希望自己可以有时间减减肥，真是身体一天不如一天了，在家陪孩子玩点什么都累的不行。

## 2019年10月11日
1. 这周二做的项目第一个版本上线了，干到凌晨0点多才走，回家睡了5个小时就起来上班了....然后白天解决了一堆线下推广遇到的问题，一天就这样过去了。
不过也收到一个好消息，我们这个项目领导很满意，给我们评了一个京东物流二等奖，听说新来的大领导还要给我们其它奖励。
2. 最近看了房子很焦虑，房价涨的太快，而我买的房子确一点不涨，唉，心里好难受，想着以后可能不会在西安，而要去别的城市，但西安的房子还要赔钱卖，
就感觉很亏，还要背上很多房贷，希望过两年我想去的城市房价能跌下来点吧...

## 2019年10月15日
1. 最近地下城玩的挺爽，练了四个号，感觉还是狂战士简单些，又把之前的几个角色练起来了，听着熟悉的音乐很有回到当年的感觉，感觉这个游戏够玩半年的，
很怀念当时去网吧疯狂玩游戏的感觉。
2. 最近不太忙，加班少了，感觉终于回到了正常的节奏，之前每天真是太累了，天天忙的都感觉活着没意思，最近终于好些了，不知道能持续到什么时候。
3. 西安的房子我昨天也弄好了合同，发送了过去，等着周一收房租。虽然这个房子跌了，但心里也是有点惦记这个房子，希望这些住的人能破坏的少一点。

## 2019年10月17日
1. 9月份提交的专利今天终于初步审核通过了，希望最后专利局能通过，虽然钱有点少，但也是我人生第一个专利。

## 2019年10月21日
1. 今天得知我这月绩效是A。第一次得A感觉很不错，还以为能得到很多钱，结果才知道计算公式，钱少的可怜....费个大劲就得这么点钱，有点不爽.....
不过也算可以了，毕竟有的人还得c呢。希望以后继续下去。
2. 以后货车app就是由我来主导了，松海要去做flutter的研究，慢慢的把他的工作转接给我。感觉责任重大啊。今天面试的人如果来了会安排到货车app这
块来，他的工资真是高啊，一个月有35k，之前还在锤子科技做了两年多，面试的时候副感觉这人技术也没有比我高，居然能面试上锤子科技，想当年我去面试
都没面上。不过也幸亏没有面上，要是面上了我现在可能在成都呢，成都那边干了一年就黄了，自己没去上也算是幸运吧。

## 2019年10月24日
1. 没想到21号感冒了，22号请假了一天，在家休息了下，而且还把暖气漏水修好了，还交了电费，感觉这次不白休啊。
2. 这周六要聚会，海底捞。
3. 今天波哥跟我说他那边现在可以招我过去，但我还是纠结怕明年没法涨工资，而且我要是异动失败了，还怕现在的领导对我有看法，综合考虑了下还是明年
再说吧。不过我真的挺想去的，感觉一直写业务代码没什么进步，很容易被淘汰，还是想更多的磨练自己的技术。

## 2019年10月28日
1. 周六去聚餐，五个小时在路上....去一次北京时间成本太高，基本一天的时间都浪费在了路上。
2. 这周要提测了，10月份也要过完了，期待月底看看能发多少工资。
3. 昨天晚上风很大，4点多就给我吵醒了，然后我怎么都睡不着了，一直躺到闹钟响，在班车上睡了半个小时多，感觉稍微好点，这要是以前在汽车之家，真的
是一天要累死。
4. 周六跟同学聚会，然后在回家的路上我也想了想，我确实最近这一年多有点松懈，不如以前那么努力了，其实以前也不怎么努力，不过多少还学习一点，
现在基本上不怎么学了，下班在舒服的班车里居然看起了新闻等乱七八糟的东西来打发时间，感觉自己真的很愧疚。我确实应该要多多学习才行了。
我想最近要学学英语，闭眼睛休息时也不听那些相声或其他什么东西了，我最近想听听关于欧洲的历史文化，我觉得这样能更好的帮助我学习英文。
还有就是想最近有空了，写下学习flutter的文章，然后有可能的话做个分享，提高下自己在组内影响力，为明年升职做准备。

## 2019年10月29日
1. 今天把Flutter启动流程的分享文章写完了，大部分是我在网上看文章学到的，然后我自己在源码上添加注释，用自己的语言把整个流程通过代码
写了一下。反正算是给自己的学习做了一个总结吧，写文章还是挺辛苦的，毕竟要考虑一些措辞什么的，希望自己写的别人能看懂，不过我知道，其实根本没
什么人会看....

## 2019年10月30日
1. 今天改了几个bug，然后又实践学习了下Fish-Redux，用起来感觉确实上手有些学习成本，再就是类太多了，而且是同名的，在修改的时候很容易做
懵了，只能用包名来区分，感觉不是很好。
2. 马上要开始双11值班了，真是不想周末过来值班啊....

## 2019年11月1日
1. 又11来了，昨天是我值班，然后就是周日了，希望周日不用来上班啊....
2. 昨天把Fish_redux的list写法学习了下，感觉真是有点繁琐，一个很简单的东西，要创建那么多的类，虽然是把逻辑与界面分开了，但用起来真的是不
太爽，写一个adapter弄那么复杂，我是有点不太喜欢....

## 2019年11月6日
1. 上周五和周一简单学习了一下Python和爬虫入门，因为最近双十一要统计各个接口的调用量，所以就想写一个脚本来抓取，一个是我确实喜欢这个技术，
第二个也是想分享给同事，显示下自己的学习成果。做成了本来挺高兴的，结果后端的一个架构师说，这个东西他就能做，没做的原因就是想让大家必须去
看看接口的调用量情况，给我恶心到了。我是很不舒服，毕竟我也是想造福大家，你给整个这个事情，而且当时一起开始的时候，另外一个架构师也说了可以
弄爬虫来统计，当时他也没吱声说什么，这回我弄出来了反而说上这些了。反正我会继续学习的，管你怎么说。
2. 昨天也是地了分享，感觉分享代码的这种并不好，这种的还是自己去看文档比较好，讲的很尴尬，而且没有逻辑性。
3. 这个周末和下个周末都要来值班，感觉很不爽啊，而且下周我还要去仓库支援一天。
4. 宝宝的感冒终于好了。

## 2019年11月9日
1. 今天周六来值班，上周程哥一直说要找我聊绩效，但也没找我聊，估计这个月对我没什么要求吧，然后绩效也不会有A了。希望年终的时候绩效给我能高一
点。说实话，我们组后端的那个T7我是觉得他基本没做什么工作，然后还给他那么高的绩效，虽然说工作上不可能有绝对的公平，但也是感觉不爽。
2. 我发现我最近嘴又有点管不住了，开始在工作中乱说话，我得控制，这样真的不好，不能说些工作上不好的话。
3. 今天值班我准备学习下iOS

## 2019年11月12日
1. 双十一过了，感觉好几次双十一了，没买什么东西，这几年主要是攒钱买房子和还钱，所以在买东西这方面就是能省就省。今年欠的钱都还完了，然后就是开
始攒钱，把省下的房贷还了，如果还不上房贷，就是想在哪个城市弄个小户型的首付钱，估计这些弄完了，是不是又要开始新的一轮攒钱了....感觉攒钱这块没
有终点，除非有一天或者某一年突然多了很多钱，这样好像就好了。
2. 昨天晚上，一个之前一起玩过游戏的人向我借钱，我果断给拒绝了，这要是以前，我可能还是纠结下，现在经历的多了，感觉这些事也就那样，该拒绝就拒绝，
要不到时难受的是自己。跟他连面都没见过，就借钱那是不可能的，认识的人都要考虑下呢。而且连个几百块钱都管理不好的人，不值得借钱。缺钱跟父母说去吧，
毕竟不是大钱。

## 2019年11月14日
1. 昨天去双十一支援，感觉货还是挺多的，比我之前支持的三次加起来的货都多，给我累的不行，中午回家的时候钥匙还落在站点了，又回去取了次，给我气的不行。
卸了大概13车货，今天早上醒来感觉身上酸酸的，没有力气。看来今年大家购物欲望很强啊，买了不少东西。
2. 最近dnf有点玩够了，不知道为什么，好像除了升级，别的没有什么欲望了，要是刷装备，那几个图也刷够了，然后开小号又把所有图再重刷一次，也感觉
很没意思。依稀记得前两个月刚玩的时候心里激动的感觉，确实有一种好友久违重逢的感觉，当打开游戏听到背景音乐，像是又回到了过去那段大学时光。其实
那段时光并不好，但就是喜欢。

## 2019年11月20日
1. 这几天真是忙的晕头转向的，然后上周还遇到了Flutter滑动冲突的bug，一直困扰着我，感觉无法解决睡觉都不踏实。还好11月18日那天都给解决了，终于
心情舒畅了一些。昨天上线又改bug，浪费了一天的开发时间，这次给的时间太紧张了，刚入职的同事本来是进到我这边帮着开发的，结果媳妇早产他又请假回去
了，开发时间在11月15日又跟大家对了下，然后又延期了两天提测才感觉稍微透口气，前天又得知松海的爷爷去世了，他要回趟老家....这可真是青黄不接了，
人不够用，开发时间还少。今天来看看他手头还剩多少工作量，真的不希望周末来加班，最近忙碌的难受，每每都有不想干了的感受。
2. 昨天跟媳妇一起看了下成都，之前因为那边总是地震我俩就放弃那边了，昨天看了下工作和网上说的地震的事情，感觉还行，媳妇说也可以考虑下那边。
除了地震的事情，我是挺喜欢那边的，可能是因为蜜月旅行的时候去的那边，感觉心情舒畅吧，当时玩的也比较开心，不知道如果真在那边生活的话会怎样。

## 2019年11月26日
1. 最近真是太忙了，一堆事压在身上，然后又要发生了组内变动。上周程哥跟我说我们组内会大调整一下，大概在12月就会说这个事，我现在做的项目会被
分给别的组，包括我们组另外三个项目也是，都要被分出去，他问我是要跟他一起走还是跟着app走。我想了想还是跟他走比较好吧，毕竟他也算是比较了解
我，然后也有可能会给我涨点工资，如果被分到别的组里，可能新领导不认识我，给我加薪也不会考虑太多。明年不知道会怎么样，我只是想忙活了这半年，
最后能涨个工资吧，毕竟去年就没涨，还差点被裁员，明年涨点工资，然后能去上波哥的组多学点技术，做这种业务代码真的没什么意思，感觉就是浪费了
自己的职业生命，时间越久越不值钱。
2. 昨天晚上我们组内聚餐了，算是分别之前的一次聚会，我们组人挺多的，27人，感觉大家相处的也还不错，这次聚会虽然吃的不太合口，但感觉还可以，
希望以后会越来越好吧。
3. 11月23日周六还来加班了一天，因为松海的爷爷突然去世了，所以他的活就分给我来做了，本来我那部分活就挺多，再把他的分给我，就更多了，
真的是比较突然，然后我周六来加班了一天，顺带把一个不好解的bug给解了，感觉周六这天还是比较顺利的完成了工作。感觉疑难Bug如果当天解决不了，
最好的的办法就是去睡觉，然后第二天基本就有思路给解决了。

## 2019年11月27日
1. 昨天波哥跟我说他那边有编制了，只要没问题肯定能异动成功。但我这边一直是想着明年能涨下工资，年终奖也希望能稍微多点，怕现在去他那边，那边领导
看我对他们组也没什么贡献，最后什么都不给我，感觉有点亏，我又白干一年。我现在在程哥这感觉干的还算可以，但现在又要组内变动，不知道明年到底会怎么
样，去波哥那倒也挺好，因为程哥这边确实也没什么好的项目，再干也是重开一个项目，但用户量肯定是不大，感觉以后也有被裁员的风险，波哥那边至少能学
到技术，这些一直写业务代码也没什么进步，出去找工作竞争力也就那样。所以昨天跟媳妇商量了之后还是决定去波哥那，然后就把简历发给波哥了，希望能异动
成功吧，以后会有更好的发展。

## 2019年11月28日
1. hr的效率是真慢啊，这都两天了，连个电话都没打，我内心还是有点着急的，怕没异动成功。下个月差不多就开始从我这边抽人了，然后组内结构调整也怕
是要跟着开始，就怕到时因为这个而耽误我进行异动。
