# DayDayUp_2019
2019年学习工作历程记录

---
## 2019年1月7日
1. 元旦请了三天假，连上了周末两天，休了一个小长假，本来很开心可以多看看女儿，没想到我发烧了，然后又传染给了女儿，女儿直接住院了，我也不能离她太近，
怕再传染给她。我昨天坐火车走了，她还没有出院，希望今天晚上不发烧明天可以出院。
2. 今年形式很严峻，裁员的公司很多，一个岗位有很多人竞争，必须要抓紧时间学习了，没有紧迫感最后都是要被淘汰的，尤其是程序员这行。最近准备整理下学习计划，
3. 今天把运营平台项目中所有的中文字符转成翻译好的英文了
4. 感冒还没好利索，头疼

---
## 2019年1月8日
1. 修改运营平台海外版翻译错误
2. 调研海外版地图，目前谷歌和腾讯均要收费，明天看看百度地图
3. 开发通过点击地图添加圆型空域圆心
4. 开发多边形空域点击地图添加点
5. 开发线形空域点击地图添加点
6. 开发点按钮显示和隐藏逻辑

---
## 2019年1月9日
1. 添加空域点列表可滑动到当前下标
2. 添加提交按钮

---
## 2019年1月10日
1. 添加空域点图片
2. 修改线形空域添加和删除点逻辑
3. 最近状态很差，干什么都干不进去，想学习看会pdf就看不进去了，很焦虑。昨天领导找我们组的每个人都谈话了，我感觉我们组有点危险....不知道最近会有怎样
的变化
4. 添加空域退出判空拦截逻辑

---
## 2019年1月11日
1. 心态很差，需要调整。还好姑娘今天出院了，终于都治好了，下次我再得病啥的可得离远点，要不全家人跟着一起遭罪。
2. 首页的UI逻辑和接口了解了下，下周准备做这块
3. 算法的大O表示法看了一点

---
## 2019年1月14日
1. 有可能被裁员，要开始看看面试题了...会认真的考虑下要不要转到西安
2. 中午去健身了

---
## 2019年1月15日
1. 看了一下数据结构和算法的知识，复习了一下数组、二分查找、跳表、快速排序、归并排序
2. 开发首页接口自动请求逻辑，和一些生命周期关闭接口自动请求逻辑
3. 开发首页网络状态监听广播，目前在注册和反注册方面还有问题，要找到一个比较好的注册和反注册的调用节点
4. 今天组里的同事进行了投票，选出组里贡献最多的人，没想到我会排在第一位，我以为我是后来的，跟大家都不熟悉，基本没什么人会投我，
结果让我比较意外，感谢大家，我是幸运的，要继续努力，虽然不知道年后我们组结果会怎样，但自己不能放弃，只有不断努力，才会更幸运。
也要给女儿做个榜样，要是连我都放弃了，家就完了

---
## 2019年1月16日
1. 中午健身了，工作变动的事看看年后怎么弄吧，尽量走异动，如果这次我再离开京东估计这辈子基本上就进不来了
2. 开发提交空域逻辑，接口目前有问题
3. 开发提交判空逻辑
4. 学习了LinkedHashMap原理，但还有点不太理解，明天再看一次

---
## 2019年1月17日
1. 开发首页搜索无人机逻辑
2. 修改搜索界面数据解析错误问题
3. 把LinkedHashMap原理重新看了一次，理解了其中原理
4. 同事说他有可能会把北京房子卖了去苏州，感觉也不错，北京的生活确实太累，花300万只能买个又小又老的房子，但去苏州就不一样了，生活
质量能提高很多。我们普通的打工者，目前真是没有办法在北京立足，很多人都跟孩子异地，只有放假的时候才能看看孩子，感觉这样活着很难受。
我们努力只是想活的好点，但发现，你怎么努力也就那样，看不到头，只是存款多了些，那又怎么样呢，省吃俭用住着一个不足20平米的卧室，北京的
房子依然买不起，孩子也没办法来到身边。
人生就那么几年，活着到底是为了什么，总是说为了下一代，但我们自己呢，当前的生活我们选择负重前行，这没有错，也是应该做的，但要看牺牲的代价是
什么，更多的人牺牲的是自己的生活时间和健康，最后带来的是什么，如果身体健康是最好的，一但生病就什么都没了。这是一种不健康的生活状态，但这恰恰
是目前大多数人的生活方式。其实我们不想这样，只是没办法，只能扛着。

---
## 2019年1月18日
1. 开发首页搜索无人机逻辑，这块逻辑和界面今天找产品确认了下，重新做了
2. 哈希算法的应该看了下

---
## 2019年1月21日
1. 开发首页搜索无人机逻辑
2. 开发首页无人机列表逻辑
3. 开发无人机列表选中逻辑
4. 今天看了一下面试题，看了下热修复原理
5. 开发圆型空域高度和备降点逻辑，还差提交逻辑没写，完成度80%

---
## 2019年1月22日
1. 开发圆型空域高度和备降点逻辑
2. 修改提交空域崩溃Bug
3. 修改多边形空域点下标计算错误
4. 开发多边型空域高度和备降点逻辑
5. 今天发了春节礼包，感觉还不错
6. 最近一直在健身，希望年后了依然可以坚持...不过这个取决于工作，希望年后有好消息，今天波哥也跟我说了一些，还是有一点希望的

---
## 2019年1月23日
1. 添加首页电子围栏接口
2. 添加首页计划和申请计划跳转

---
## 2019年1月24日
1. 开发圆形空域编辑逻辑
2. 修改提交圆形空域缺少备降点bug
3. 开发空域编辑多边形逻辑
4. 今天开会，说了下年度绩效低会被裁员的事情，感觉很压抑，之前总听说经济不好公司会裁员，没想到会发生到自己身上，希望明年好运吧。
今天本来中午要去游泳，结果因为这个事没去上，看看明天能不能去，不希望再有坏消息传来了....

---
## 2019年1月25日
1. 开发线形空域编辑逻辑
2. 开发空域成功后回调逻辑
3. 开发首页电子围栏逻辑，进度60%

---
## 2019年1月28日
1. 添加首页空域围栏逻辑
2. 修改首页飞机详情页UI
3. 添加空域成功后返回空域类型入参
4. 今天中午本来要去健身，结果波哥要开会就没去上...

---
## 2019年1月29日
1. 添加批件输入公司名称逻辑
2. 修改添加空域返回字段类型
3. 添加空域回调aire数据
4. 添加联系人界面逻辑
5. 添加联系人和公司页back判空，添加联系人页最少添加一人逻辑
6. 添加空域引导页

---
## 2019年1月30日
1. 添加首页飞机飞行轨迹逻辑
2. 添加无人机详情信息自动更新
3. 添加首页按两次back键退出app
4. 今天就有一部分同事回家了，我的票还在抢，希望能抢到，提前两天到家

---
## 2019年2月13日
1. 今天休完了春节假期正式开始上班，今年不知道会有怎样的变化，房子也快到期了。
2. 修改首页崩溃问题
3. 修改空域添加点不可拖拽
4. 修改首页接口多次调用bug
5. 小宝宝长牙了，有一种小草发芽破土而出的感觉

---
## 2019年2月14日
1. 在纠结要不要看看外面的机会，其实很想留在京东，第一选择还是想内部异动
2. 昨天学习了下Flutter的基本原理
3. 整理了下简历，之前的简历确实有好多细节方面没有做好，改了很多，这样是不是也说明我进步了很多，所以才能知道以前不对的地方。

---
## 2019年2月15日
1. 运营平台国际版嵌入google地图，但是需要手机支持Google Play服务，在网上查目前国产手机都不支持这个，太坑了，看来还要找找其它方法
2. 学习了下安卓的类加载模式原理
3. 解决flutter编译正式包没有libflutter.so问题。windows要在编译命令加上指定的cpu类型。
flutter build apk --target-platform=android-arm64

---
## 2019年2月18日
1. 添加首页无人机飞行方向逻辑
2. 今天学习了flutter运行原理方面的知识，有一些知识是之前刚做flutter时看的，当时有一些东西看的似懂非懂，现在又看一次感觉理解了很多，
目前很想知道flutter运行时是怎么渲染界面和flutter如何与C++本地方法进行调用的。

---
## 2019年2月19日
1. 修改原生接口token
2. 今天看了下flutter原码，找到了flutter调用C++本地方法的地方，其实就是调用dart虚拟机的lib库，然后lib通过jni调用android的原生方法，进行
回调，然后flutter就能与原生通信了。
3. 感觉还是后端的工作机会多一些，最近公司论坛内部异动技术方面大都是后端的，前端的没有，看来有机会还是要学些后端的东西，到时可以转过去。
以后也不想再做业务方面的东西，想做平台层的一些专门做技术方面的，这样就不依赖业务的好坏和盈利而被砍掉了。

---
## 2019年2月20日
1. 学习了数据结构堆方面的知识

---
## 2019年2月21日
1. 搭建空域pad版项目框架，引入平台通用控件
2. 空域pad版工时评估，任务分配
3. 今天学习了数据结构和算法方面的图，准备把数据结构和算法的课程先整体学一遍，把学不明白的先跳过去，看完整体课程后再把之前看不明白的深入研究下，
这个是我在书上看到的新的学习方法，可以试试效果

---
## 2019年2月22日
1. 空域pad版首页UI开发
2. 学习了一些搜索算法方面的知识
3. 学习了dart调用C++方法的知识

---
## 2019年2月25日
1. 学习了c语言基础知识，终于明白了include的意思，以前一直不明白这块，感觉这块写着很奇怪，这块明白了也就知道c语言的项目要怎么处理项目结构
2. 得知同事因为犯了事被关进监狱了，这么年轻孩子也刚出生没多久，太可惜了，平时虽然跟这个同事接触比较少，但感觉这个同事人还可以，没想到会这样，
早上来的时候还在食堂见到他了，没想到上午就被警察带走了
3. 最近很迷恐怖黎明啊
4. 周末把房子定下来了，又续租了一年，希望今年可以留在京东，然后班车不要取消....第一季度还有一个月，希望第一个季度完事后我能被调走，祈祷吧。
然后这几天也要不断的学习，给自己的能力提高一下。我想把ios学习下，这样更能有助也我学习flutter这样的跨平台方案，可以理解两边的开发写法。在
传智播客找到了学习ios的视频，先从学c语言开始吧，比较这是oc的基础。
```c
include其实就是把代码直接复制到当前的文件中，一般c语言在使用一些函数时，需要先声明再使用。如果要使用别的文件的代码，就要使用include把
别的文件的.h文件包含进来，.h文件里写的都是函数的声明，并没有函数体，函数体都在与.h文件同名的.c文件中。
这样引入了.h文件，就可以使用.h中声明的函数了。多文件开发就是这个原理。
```

---
## 2019年2月26日
1. 今天学习了c语言的进制方面的知识
2. 运营平台国际版替换了所有的google地图和逻辑修改，昨天我把google需要的环境都安上了，但是google还是打不开，应该是不能翻墙的原因
3. 替换国际版单词过长的部分
```c
当声明一个变量申请一块内存区域的时候，所申请的地址都是从内存地址的最高位开始的，而变量的引用或指针所指的地址是低位的内存地址。
所有的数据在内存中都是以二进制来存储的，一个字节有8位，每个位都用0和1来表示。在内存中每个字节都有一个16进制的地址相对应。如int有4个字节，
就有32位，而左边第一位则是用来表示数据的正负的，只有31位是用来存储当前的数据的。
内存中，所有的数据都是使用二进制的补码来存储的，所有的正数的二进制的补码等于它的原码，所以不需要转换。而负数的就需要先把原码转成反码，然后再
把反码转成补码，这样做是因为计算机只能算加法，不会算减法，如果直接使用原码来处理减法最后的结果是错误的。
```
---
## 2019年2月27日
1. 学习了数组方面的知道，也理解了之前c语言中有数组为入参的方法为什么要传递数组的长度了，因为这个在java中是根本不需要的，所以这块一直没有
理解，写代码的时候也常常会忘记。
```c
int[] a = {1,3};
//a是数组第一个元素的最低位的地址，通过这个来找到数组，a[0]等于数组的第一个元素的值。
//在内存中申请地址都是从高位向低位来申请的，但是数据的第一个地址在低位。
test(a);
void test(int[] a)
{

}
//当一个函数以数组为入参的时候，调用函数时数组传递的是地址，而且函数接收时，实际是一个存储数组地址的变量。这个
//变量长度只有8个字节，使用这个地址是无法知道数组的长度的，所以在定义以数组为入参的方法时还要加上一个数组长度的
//入参才可以。
void test(int[] a，int len)
{

}
```
2. 学习了c语言中字符串的原理，因为在电脑的世界里是没有字符串这个东西的，只有8种基本数据类型，但要存储字符串就要依靠字符数组，字符数组每
一个元素都存着字符串中的每一个字符，然后在字符数组的最后一位加一个'/0'来表示字符数组结束，这样是有的数组很长，但里面存的字符并没有达到
数组的长度，'/0'后面都是垃圾值，所以要使用这种方法。字符数组要多申请一个字符长度用来存储'/0'
```c
char[] a = "dfa";
char[] b = {"daf"};
char[] c = {'a','b','/0'};
//下面的数组第二位到最后一位的数据都'/0'
char[5] d = {'a'}
```
3. 解决运营平台两处安全问题
4. 解决运营平台用户个人隐私数据调查

---
## 2019年2月28日
1. 本月的最后一天，也是发工资的日子，提前发工资的日子很好，但是也会感觉时间飞逝，第一季度也快完事了。今天得知波哥下周就要去商城的部门了，
不知道那边会怎样，希望能好些，到时那边有编制可以把我也调动过去，我也是不太想做业务方面的技术了，感觉天天写一样的代码没什么进步，还是得专门
研究技术比较好，这样才是真正的靠技术吃饭。
2. 上午的时候被同事告知，之前已经结项的项目他还有三个界面没做完，而且一直瞒着我到现在，这个本来是要年前做完的，结果到今天了才告诉我，真是太气人
了。天天上班做考研题学公务员也就算了，这点活还干不完，影响了本职工作，真是没见过这样的人，这种人去哪了都一样，估计公务员他也靠不上，以后写代码也
是要被淘汰的人。希望最近能把他裁掉。
3. 做了一个下午上面的同事说做不出来的日历控件，基本已完做完了，这个东西是有一点难度，但还没难到2个月都做不出来的程度吧，真是服了。

---
## 2019年3月1日
1. C语言字符串长度
```c
字符串的长度
char name[] = "jack";
这个时候字符数组name初始化的时候没有指定的长度，但是他的长度是5，因为要加上后面的'/0'
注意，sizeof输出上面数组的长度是5，其中包含最后一位的'/0'

char name[10] = "jack";
这个时候字符数组name初始化的时候有指定长度，他的长度度就10，只是使用到了前面5个字符，后面的值都是'/0'
注意，sizeof输出上面数组的长度是10
char name[] = "中国"
这个长度是7，因为一个中文占3个字节，但是不可以单独使用name[0] = '中'这样赋值，因为char只能占一个字节。
```
2. 字符数组注意点
```c
如果字符数组里中间的位置有'/0'字符，后面的字符会作废。
char str[] = {'a','b','/0','c'};
这里只会输出ab
```
3. 字符串的输入
```c
当输入的str里带有空格，sacaf函数里会认为空格表示输入结束，str里只会保持空格之前的数据，只能使用另外一个函数
char str[];
sacaf("%s",str);
```
4. 字符串常用函数
```c
下面两个函数在#include<stdio.h>中
puts()
作用:输出字符串，且自动换行，但只能输出字符串，也不能使用占位符。

gets()函数
作用:从控制台接收用户输入1个字符串数据，遇到字符串包含空格不会截断后面的字符串。缺点是不安全，入参数组的长度超出
时程序会崩溃

下面四个函数在#include<string.h>中
strlen()
作用:得到字符数组的字符串长度，返回值是size_t,是个unsigned long类型

strcmp()
作用:比较两个字符串的大小，返回负数说明字符串1比字符串2小，返回0说明相等

strcpy()
strcpy(name1,name2)
作用:拷贝数组数据到另外一个数组,把name2拷贝到name1，不安全，name1的长度可能比name2长度小，会产生崩溃

strcat()
strcat(name1,name2)
作用:把两个字符数组相连,把name2连接到name1的后面，不安全，name1的长度可能放不下两个数组的长度，会产生崩溃
```
5. 指针
```c
指针
变量的地址就叫指针，指针就是地址

指针变量
作用:是专门用来存储地址的变量，存储另外一个变量的地址。
使用指针变量的好外:间接访问指向的变量
int* p1;
*代表变量不是普通变量，而且用来专门存储地址的。这个p1指针变量只能存储地址。

指针变量的初始化
int num = 10;
int* p = &num;
而指针变量自身也是有地址的，使用&p就可以取出地址，其实就可以把指针变量当成一个普通的变量就行，只是存的值比较特殊。

使用指针变量操作指向的变量
int num =10;
int* p1 = &num;
*p1 代表p1指针指向的变量，也就是num
*p1 = 100; 将100赋值给p1指针指向的变量，也就是num

使用指针变量注意的问题
int* p1,p2,p3;
这样只有p1是指针变量，p2、p3都是int类型
如果希望都是指针应该这么写
int* p1,*p2,*p3;

野指针
声明一个指针变量，如果没有为其初始化，这个指针变量里是垃圾值，指向了一个随机的空间，这种
就是野指针。使用这样的指针如果指向的空间有被其它人使用会报BAD_ACCESS错误，但如果指向的空间是
无人使用的不会报错。
修改野指针还可能会造成别的程序崩溃。

NULL值
为了避免野指针出现，可以先给指针变量赋值为NULL。代表这个指针变量不指向内存中的任何地址
NULL等价于0，也可以给指针变量赋值为0,但不建议这样做。
int *p = NULL;
int *p1 = 0;
使用NULL的指针会直接报错

多个指针指向同个变量
int* p1 = &num;
int* p2 = p1;
这时p1和p2都指向num的地址，*p1和*p2访问的都是num变量。

指针用在什么地方
当普通变量作为函数的参数时，在函数中无法改变入参的值。
void test(int* p)
{
   *p = 1000;//这里会改变num的值
}
int num = 0;
test(&num);

什么时候需要将指针作为函数入参？
1. 当函数的返回值大于一个以上时。可以在函数的入参加上指针。
int getMaxAndMin(int arr[],int len,int* min)
{
	int max = INT32_MIN;
	*min = INT32_MAX;
	for(int i =0;i<len;i++)
        {
            if(arr[i] > max)
            {
                 max = arr[i];
             }
             if(arr[i] < *min)
             {
                 *min = arr[i];
              }
         }

         return max;
}
第二个例子，这样scanf直接就改变了num的值。
int num = 0;
scanf("/d",&num);

指针为什么要分类型
任何类型的指针都占8个字节。因为指针变量可以存储任何变量的地址，但无法知道所存变量的类型长度，
所以要指定指针变量的类型。
int num = 10;
int* p = &num;
p指针变量中存储的是num变量的低位的地址，所以知道变量类型的话就能找到所指向的变量在内存中的
长度，就能知道可以连续操作多少个字节空间。int* 就可以连续操作4个字节，double*能操作8个字节的内存空间。

多级指针
一级指针
只能存储普通变量的地址
int num = 10;
int* p = &num;

二级指针
只能存储一级指针变量的地址
int** p1 = &p;

三级指针
只能存储二级指针变量的地址
int*** p2 = &p1;

二级指针的使用
int num = 10;
int* p1 = &num;
int** p2 = &p1;
*p1 = 200;
*p2 //代表p2指针指向的变量，也就是p1的地址
int age = 10;
*p2 = &age;// 这里的*p2的值是p1的地址，然后p1保存了age的地址
**p2 //代表p2指针所指向的指针所指向的变量
**p2的值为10
```
---
## 2019年3月4日
1. c语言
```c
指针与整数的加减法
指针与整数进行加减运算
比如指针+1，并不是在指针的基础之上加1个字节的地址，而是跟在这个指针基础之上加1个单位变量占用的字节数。
如果指针类型是int* 那么1代表4个字节地址。
如果是double*，那么1代表8个字节地址
int num1 = 10;
int num2 = 20;
int* p1 = &num2;
int* p2 = p1+1;

指针与数组
一维数组在内存中是连续的空间
int arr[3] = {10,20,30};
一维数组的地址
是数组的低字节的地址
数组名就是数组的地址

定义一个指针指向数组中的元素
int* p0 = &arr[0];
int* p1 = &arr[1];
int* p2 = &arr[2];
*p0 = 100;
*p1 = 200;
*p2 = 300;
数组中的元素值改变。
int* p3 = arr;//与p0相等

*(p3+1)与*p3+1的值不一样
因为*运算符比+运算符的优先级别要高，所以会先运算*p3的值，然后再加1

使用指针遍历数组
第一种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(p3+i));
}
第二种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(arr+i));
}
第三种方式
for(int = 0;i < 3;i++)
{
    print("%d\n",*(p3++));
}
注意每次循环后p3的指针都指到数组外面去了，就不再指向数组中的元素了，
所以再次遍历要重新赋值
但不能使用*(arr++),因为数组名代表数组地址，数组一但创建地址就确定了，是
不能改变的。

数组作为函数参数
在声明这个参数数组的时候，并不是创建一个数组，而是去创建1个用来存储地址的指针变量。
编译在编译的时候，已经把这个数组换成了指针
void test(int arr[],int len)
{

}
变成,建议写成这种方式
void test(int* arr,int len)
{

}
```
2. 修改日历控件能切两个日历，但引入了一些Bug，目前还有一个箭头的bug要解
3. 从今天开要开两会，我们的班车也要换到白庙收费口那上车了，每天要转车然后走过去，好累

---
## 2019年3月5日
1. 改了一天日历控件bug
2. 添加日历控件第一次启动时显示数据为空
3. 修改日历控件显示月份为中文

---
## 2019年3月6日
1. c语言学习
```c
存储int指针的数组
int num = 100;
int num = 200;
int* arr[3] = {&num,&num1}
//改变指针数组里指针变量所指向的变量的值
*(arr[0]) = 3000;
//该变指针数组里指针指向的变量地址
int num3 = 300;
arr[1] = &num3;

指针和指针之间可以做减法运算，但结果是1个long类型的数据。代表的是两个指针变量之间相差
多少个单位变量。绝大多数情况下用在判断数组两个元素之间相差多少个元素。
如果参与减法运算的两个指针不指向同一个数组结果就会有问题。
int* p1 = &num1;
int* p2 = &num2;
long res = p2 -p1;

指针之间的比较运算
先声明的变量的地址要大于后声明的变量的地址，因为先声明的变量地址在高地址。
p1 > p2

内存中的五大区域
栈
专门用来存储局部变量

堆
允许程序员手动的从堆申请空间来使用。程序员自己申请指定字节数的空间。

BSS段
存储未初始化的全局变量和静态变量

数据段/常量区
用来存储已经初始化的全局变量、静态变量，还有常量。

代码段
用来存储代码/指令

为什么要分五个区域?每个区是干嘛的?
不管是哪个区域都是用来存储数据的。
不同的数据存储在不同的区域，方便系统管理。

存储字符串的两种方式的区别
1.使用字符数组来存储:将字符串数据的每1个字符存储到字符数组的元素中，
追加1个'\0'表示结束。
char name[] = "jack";
2. 使用字符指针来存储:直接为字符指针初始化1个字符串数据
char* name = "jack";
区别
char name1[] = "jack";
char* name2 = "jack";
1. 当他们都是局部变量的时候
name1字符数组是申请在栈区，字符串的每一个字符存储在这个字符数组的
每一个元素中。
name2这个指针变量是声明在栈区的，字符串数据是存储在常量区中的。
字符串数据就是以字符数组的形式存在常量区的，把地址给栈中的指针变量。
2. 当他们作为全局变量的时候
name1是在常量区的内存中存储的。
name2指针变量也在常量区中，并且指向存在常量区中的数组地址
区别对比
1.申请内存存储的区域不同
2.name1字符数组不管是局部和全局的，里面的元素是可以修改的
不管是全局的还是局总的变量name2以字符指针变量声明的字符数组是不可以修改的
```
2. 修改日历控件第一次不默认选中日期
3. 修改日历控件确定按钮逻辑
4. 开发空域管理Pad版首页UI和部分逻辑
5. 同事们都因为要被裁员而不干活了，感觉多干了自己就吃亏了，其实我觉得吃亏的是自己，尤其是自己的声誉上，被领导贴上了不靠谱的标签。
以后领导再有好的机会可能就不会考虑这样的人了。我是觉得能干一天就要做一天的活，毕竟还领着公司的钱，而且自己也能被领导所看好，觉得
你比别人都靠谱。

---
## 2019年3月7日
1. c语言学习
```c
字符串的恒定性
大前提:是以字符指针形式存储的字符串。
1. 当我们以字符指针的形式存储字符串的时候，无论如何字符串数据都是存储在常量区中。
并且一旦存储到常量区中去，这个字符串数据就无法更改。
2. 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到
常量区，而是先检查常量区中是否有相同内容的字符串。
如果有，直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储在常量区。
3.当我们重新为字符指针初始化1个字符串的时候，并不是修改原来的字符串，而是重新创建了1个字符
串，把这个新的字符串的地址赋值给它。
4.容易混淆的地方
char *name = "jack";
name = "rose";
这样是可以的，只是在常量区新创建了一个rose字符串
char name[] = "jack";
name = "rose;
这样是不行的，因为name代表的是数组名称，不能为数组名赋值，可以使用下面的方式改变数组内容。
name[0] = 'r';
name[1] = 'o';

字符串数组
1. 使用一个二维字符数组来存储多个字符串，每一行都是一个字符串。
这个数组的每一行是1个长度为10的char一维数组。
但每1个字符串的长度不能超过列数减1，也就是9个
char name[][10] = 
{
   "jack","rose"
};
2.使用字符指针数组
char* name[4] = {"jack","rose"};
每个元素的类型是char指针,初始化给元素的字符串数据是存储在常量区的，元素中存储的是字符串在
常量区的地址。
使用这种方式的好处是每个字符串的长度无限制。

const关键字
用来修饰变量。一般情况下来说，变量具备一定程度上的不可变性。
1.const修饰基本数据类型的变量
const int num = 10;
int const num = 10;
这两种效果一样，都不能再次赋值
2.const修饰数组
const int arr = {10,20};
arr[0] = 100;这里是错的，元素不能修改
3.const修饰指针
int num = 10;
const int* p = &num;
*p = 20;//这里不能修改，报错
无法通过指针去修改指针指向的变量的值。但直接操作变量是可以修改的。
int num2 = 10;
*p = &num2;
但指针变量的值可以修改。可以把另外一个变量的地址赋值给这个指针。
int const *p1 = &num1;
效果同上
int * const p1 = &num;
int age = 20;
p1 = &age;//这里报错
*p1 = 100;//这里可以
int const * const p1 = &num;
这里什么都不可以改

const使用场景
1.const特点
被const修饰的变量是只读变量，只有取值不能改值。
2. 不允许别人去修改值的时候使用
3. 当函数的参数是一个指针的时候，函数的内部有可能会修改实参变量的值。
可以给函数的参数加一个const来修饰，这样函数内部就无法修改了，保证了数据的安全性。
void test(const int * num)
{

}


如何向堆区申请字节空间来使用
1. 我们在堆中申请的字节空间，如果我们不主动释放，那么系统是不会释放的，除非程序结束。
2. 在堆中申请字节空间的步骤
申请
使用
释放
3. 如何在堆区申请指定的字节数的字节空间呢
malloc()
calloc()
realloc()
这三个函数的声明在stdlib.h的系统头文件中。
4. malloc函数
int* p1 = malloc(4)
参数只有一个，是size_t类型也就是unsigned long。
作用是向堆空间申请指定字节的空间来使用。
参数代表的意义是，向堆内存申请多少个连续的字节空间。
返回值是void *，代表没有类型的指针。返回的是创建的空间中第一字节的地址。地址没有类型。
int* p1 = malloc(8);
p1操作的时候是以4个字节为基本单位。
5. 在堆区申请的空间是从低地址向高地址分配的。
且每次申请的字节地址都是从0开始的，每次申请的字节空间不一定是连续的。但是每次申请的指定个
字节，这些字节一定是连续的。
6. 在堆区申请的字节，里面是垃圾值，不会自动清0。
7. 在向堆区申请字节空间的时候，有可能会申请失败。如果申请失败返回的指针是NULL值。
我们申请完空间之后，最好是判断一下，是否申请成功。
int* p1 = malloc(12);
if(p1 != NULL)//判断申请成功
if(p1)//这样也可以判断申请成功
8. 申请完的空间一定要记得释放
free(指针);
free(p1);

calloc函数
优点是，申请完空间之后，系统会将字节中的数据清零。
calloc(size_t,size_t)
申请3个int类型的字节空间，也就是12个字节空间
int* p1 = calloc(3,sizeof(int));

realloc函数
作用是扩容，当我们发现我们之前在堆区申请的字节空间不够用的时候可以使用realloc函数
int *p1 = calloc(3,sizeof(int));
int *p2 = realloc(p1,4);
如果原来的空间后面还有剩余的空间，且足够扩容，则直接在后面的空间扩容。
不够的话重新找一块足够的空间，将原来的数据拷贝过来，原来的空间被自动释放。

指针与函数
1.指针作为函数的参数
在函数内部可以通过这个参数指针去修改实参变量的值

2.指针作为函数的返回值
下面是错误的代码
int* test()
{
  int arr[] = {10,20};
  return arr;
}
int* arr = text();
这样是错误的，因为test函数中的arr数组在test函数执行完成后被回收了，它是一个局部变量。
不能返回局部变量的地址。
如果要返回一个指针，要保证这个指针指向的空间在函数结束后仍然存在。
那么这个时候，就可以将空间申请在堆区，然后返回堆区的地址。一定要记得，调用者使用完了之
后一定要释放掉内存。
下面是改正后的代码
int* test()
{
  int* arr = calloc(3,sizeof(int));
  return arr;
}

如果函数的返回值是字符串，那返回值类型就是char*。
字符串常量存储在常量区里，可以直接返回这个字符串的地址，不用在堆区申请空间。
申请在常量区的空间是不会被回收的。
char* getWeekDay(int day)
{
  return "monday";
}
```
2. 修改运营平台国际版崩溃问题
3. 我们大组今天说明天晚上要去团建，我们组的人大部分都是要被裁员的，都没什么心情去。

---
## 2019年3月8日
1. c语言学习
```c
指向函数的指针
声明方式
返回值类型(*指针名)([参数列表]);
只能指向没有返回值，并且没有参数的函数。
void (*pFunction))();
int (*pFun)(int num1,int num2);
函数名代表函数的地址
void test(){}
void (*pFunction)() = test;
如何调用函数指针,下面两种方式都可以
pFunction（）
(*pFunction)()

结构体
struct 新类型名称
{

};
struct student
{
   int age;
   char* name;
};
上面只是声明了一个结构体类型，在使用时还需要再声明一个结构体变量。这个时候才会在内存中申请空间。
struct 新类型名称 变量名;
struct Student stu;
stu.name = "jack";
stu.age = 10;
匿名结构体
不可以再创建新的变量
struct
{
   int age;
   char* name;
} jeo;

结构体变量的初始化
1.先声明变量，再用.初始化
2.直接初始化，这种最常用
struct student lili = {"jack",20}
3.在声明结构体变量的同时，按顺序初始化部分成员
struct Student lili = {"li"};
4.指定成员初始化
struct Student jim = {.name = "ji",.age = 10};

结构体变量的成员的默认值
结构体变量的成员的默认值是垃圾值，只要在声明结构体变量的同时，只要初始
化1个成员，其它的成员都会被自动初始化为0

相同的结构体变量之间是可以相互赋值的，结构体之间赋值是值传递
struct Student jim = {.name = "ji",.age = 10};
struct Student li = jim;

结构体数组
元素类型 数组名[数组长度]
struct Student stu[5];
stu[0] = jim;
初始化方式
1.通过下标为结构体每个元素赋值
2.当我们为结构体数组的元素赋值的时候，如果直接使用大括弧来初始化，就必须
要在前面加个类型强转，告诉编译器我们要给的数据类型是结构体类型。
sut[0] = (struct Student){"qiao",12};
3.在声明结构体数组的同时，就给元素初始化。
struct Student stu[5] = {{"qiao",12}，{"jeo",12}};

结构体数组的长度计算
先使用sizeof计算出数组占用总的字节数，使用这个总字节数除以每1个元素占用的字节数。
int len = sizeof(stu) / sizeof(struct Student);

结构体指针
struct student lili = {"jack",20}
struct Student* pStu = &lili;
结构体指针访问结构体里的变量成员两种方式
(*pStu).name = "qqq";
pStu->name = "rose";

结构体嵌套
struct Date
{
  int year;
};
struct Person
{
  char* name;
  int age;
  struct Date birthday;
};
初始化
struct Person xiaoming = {"xiao",21,{1990}};

结构体作为函数的参数
结构体作为参数传值是值传递，除非传入的是结构体指针
void test(struct Student stu)
{
  
}
void test(struct Student* stu)
{
  
}

结构体作为函数的返回值
1.结构体类型可以作为返回值，
struct Student getStudent()
{
   struct Student s1 = {"qiao",21};
   return s1;
}
下面的代码是错误的，因为s1是局部变量，函数执行完成后就被销毁了。
struct Student * getStudent()
{
   struct Student s1 = {"qiao",21};
   return &s1;
}
如果要返回指针需要在堆内存中申请内存空间
struct Student * getStudent()
{
   struct Student *s1 = calloc(1,sizeof(struct Student));
   s1->name = "rose";
   return s1;
}

枚举
数据类型的变量的取值被限定
enum 新类型名称
{
   限定取值1，限定取值2，限定取值3
};
enum Dir
{
  East,
  South,
  West
};
表示新创建了1个数据类型，数据类型叫enum Dir

声明枚举类型变量
enum Dir dir;

注意
1.每一个枚举值都有一个对应的整形的数。默认从0开始，依次递增。
2.无论什么类型的枚举变量都占4个字节
3.枚举变量中真正存储的是枚举值对应的整型的数。
4.枚举值还可以重新赋值
enum Dir
{
  East = 10,
  South = 20,
  West =30
};

枚举使用规范
1.命名规范，首字母大写，每个单词的首字母大写。
2.枚举值的命名规范，枚举值的名称都以枚举类型来开头。

typedef
作用：为一个已经存在的数据类型取一个别名，如果我们想使用这个类型，直接使用这个别名
就可以了。
语法格式
typedef 已经存在的数据类型 别名;
typedef int qInt;
qInt num = 10;
经常使用的的size_t其实就是unsigned long，只是被取了别名而已
什么时候使用？
当数据类型很长的时候，就可以为这个数据类型取一个短一点的别名，这样使用方便。
unsigned long long int num =10;
typedef unsigned long long int hm;
hm num1 = 100;

为结构体使用typedef，声明一个短别名,分别有以下三种方式
第一种
struct student
{
   int age;
   char* name;
};
typedef struct Student stu;
第二种
typedef struct student
{
   int age;
   char* name;
} stu;
第三种
为匿名结构体使用typedef声名一个短名，最常用的方式

typedef struct
{
   int age;
   char* name;
} stu;
再使用的时候可以直接用下面的形式
stu s1;

使用typedef为枚举类型取一个短别名,两种方式
第一种
enum Direction
{
  East,
  South
};
typedef enum Direction Direction;
第二种
typedef enum Direction
{
  East,
  South
} Direction;

第三种
typedef enum
{
  East,
  South
} Direction;
直接使用
Direction dir = East;
```

---
## 2019年3月11日
1. c语言学习
```c
宏定义
它是一个预处理指令，所以它在编译之前执行。
可以为1段C代码定义一个标识
语法
#defing 宏名 宏值
#defing N 10
如何使用
在c代码中直接使用宏名就可以了
int a = N + 1;
宏的原理
在预编译的时候，就会执行源文件中的预处理指令
会将c代码中使用宏名的地方替换为宏值
在使用时要注意的地方
1.宏值可以是任意的东西，在定义的时候并不会检查语法
2.如果宏是一个表达式，使用时不会得到表达式的结果，而是直接替换为表达式
3.如果宏值如果有变量名，要保证使用前变量已经被定义
4.从定义宏的地方，后面的所有地方都可以直接使用，宏没有作用域
5.字符串中如果出现宏名，系统不会认为这是一个宏，而认为是字符串的一部分
6.宏的层层替换，
#define PI 3.14
#define R 3
#define AREA PI * R * R
AREA的宏值是3.14 * 3 * 3
doubel area = AREA;
7.如果定义宏的时候加了分号，宏值里会包括分号
解除宏指令
#undef N
作用
从解除宏指令之后的代码都不可以使用宏定义了

宏值带参数
#define N(a) a + a + a
int b = N(10);
宏代替的原理
1.先将传入的值传递给宏的参数，那么宏的参数的值就是我们传递的值
2.再把这个宏值当中使用的参数的地方换成参数的值
3.最后再将使用宏名的地方替换为最后的宏值

使用带参数的宏几点注意
1.宏不是函数，所以宏的参数不需要加类型，直接写参数名就行
2.在定义宏的时候，编译器是如何区别宏名和宏值的？
#define 空格 (中间的这块会当做宏名) 空格
所以在写宏的时候，空格要小心使用
3.为带参数的的传值是本色传递
int a = 10;
int b = N(a);
这里的N接收的只是a，并不是变量a的值，预编译期间得不到变量的值
4.宏值一旦换行就认为宏定义结束了，只有当代码很少的时候，才使用宏

条件编译指令
1.它是一个预处理指令，所以只能在预编译阶段执行。
2.作用
默认情况下，我们所有的C代码都会被编译为二进制代码，
条件编译指令的作用是可以让编译器只编译指定部分的代码。

用法
在预编译的时候，如果条件成立，就会将其中的C代码编译成二进制指令，
如果不成立，就不会将其中的c代码编译成二进制指令。

注意:
条件只能是宏，不能是变量
第一种用法
#if 条件
   c代码
#endif

示例
#define N 10
#if N = 10
printf("sdfasdf");
#endif

第二种用法
#if 条件
   C代码
#elif 条件
   C代码
#elif 条件
   C代码
#else
   C代码
#endif
其中#endif是必须要写的

第三种用法
如果定义了宏名，就编译其中的代码
#ifdef 宏名
   C代码
#endif

如果没有定义宏名，就编译其中的代码
#ifndef 宏名
   C代码
#endif

解决多文件使用#include被包含多次问题
#ifndef 宏名
#define 宏名 
  代码
#endif

static和extern
可以用来修饰变量和函数
1.修饰局部变量效果
static修饰局部变量
如果局部变量被static修饰，这个变量叫静态变量。
静态变量不再存储在栈区，而是存储的常量区
当函数执行完毕，这个变量不会被回收。
当再次执行局部变量时，声明静态变量这行代码会直接被跳过，不会再重复声明
实例
void test()
{
   static num = 1;//当函数第二次及以上被调用的时候，这行代码会被跳过
   num++;
}

2.修饰全局变量
当我们分模块开发的时候，如果要在模块中声明全局变量
1.全局变量的声明要写在.h文件中
2.全局变量的实现要写在.c文件中
3.如果将全局变量定义在模块中，这个全局变量就必须要使用static或者exter修饰
static和exter区别
使用extern修饰，这个模块中的全局变量就可以跨模块访问
使用static修饰，这个模块中的全局变量只能在当前模块中访问

static和extern修饰函数
static修饰的函数只能在当前模块中调用，无法跨模块调用
如果声明的函数没有用static修饰，那么它默认就是使用extern修饰的，可以跨模块调用

```
```oc
OC与C的不同
1.在c的基础上新增了1小部分面向对象语法
2.将c的复杂、繁琐的语法进行了封装，使用更为简单
3.oc完全兼容c语言
4.OC程序的源文件的后缀名是.m，m表示message，代表oc中最重要的1个机制，消息机制
5.#import指令
是一个预处理指令，是#include指令的增强版，将文件的内容的预编译的时候拷贝到指令的地方。
同一个文件无论#import多少次，只会包含1次。
原理:
底层会先判断这个文件是否被包含，如果被包含就会略过
6.框架
框架是一个功能的集合，苹果或者第三方事先将一些程序在开发程序时经常会用到的功能事先写好，
把这些功能封装在多个类或者函数之中，这些类和类的集合就叫框架，有点像c语言的函数库。
7.Foundation框架
这个框架提供了最基础的功能，输入和输出还有一些数据类型。
Foundation.h文件当中包含了Foundation框架中其它的所有的头文件
所以只要包含Foundation.h，就相当于包含了Foundation框架中所有的头文件。
那么Foundation框架中所有的函数和类就可以使用了。
8.@autoreleasepool是自动释放池
```
2. 今天被拘留的同事回来了，听说是因为打架的原因，感觉很不值当啊，但是有的时候就是脾气上来了，控制不了。
3. 组里有个同事异动去了别的组，然后另外一个同事也准备提离职的，还有一些人就等着被裁员，感觉组里的每个人都没有心思在这了
4. 今天把所有的c语言基本学完了，开始学习oc基础。在学习的过程中收获还是很大的，以前通过看书自学的时候，进度慢而且有些知识还看
不太明白理解不了，看视频学习感觉很多知识由老师一讲出来，感觉理解的很清楚，以前一些没明白的知识瞬间就明白了，也了解了程序运行
的一些原理，对自己之前学习的很多知识起到了一个串联的做用。看来学习C语言确实是对编程方面有很大帮助的。

---
## 2019年3月12日
1. oc语言学习
```oc
NSString
NSString类型是指针变量，专门用来存储OC字符串的地址。
OC字符串常量必须要使用1个前缀@符号
NSString *str = @"jack";
NSLog(str);//直接输出字符串
NSLog(@"大家好，我是%@",str);//使用%@来当占位符

NS前缀是什么
NextStep公司被评估收购，改名为Cocoa，被加入到Foundation框架中。
NS表示这个类是由NextStep公司写的。

@符号是什么
作用:
1.将c字符串转为oc字符串
2.OC中绝大部分关键字都是以@符号开头

OC程序的编译、链接、执行
1.在.m文件中写上OC源代码
2.使用编译器将源代码编译为目标文件
cc -c xx.m
3.链接
cc xx.o -framework Foundation
-framework Foundation是链接OC程序必须要加的，c语言不用加
如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉
编译器去哪个框架中找类。
4.链接成功后会生成一个a.out可执行文件

OC当中的数据类型
1.OC中支持C语言中的所有数据类型
2.BOOL类型
可以存储YES或者NO中的任意1个数据
一般情况用来存储条件表达式的结果
BOOL本质是
typedef signed char BOOL;
实际上BOOL类型的变量是1个有符号的char变量
#define YES((BOOL)1)
#define NO((BOOL)0)
平时开发主要使用BOOL
3.Boolean
可以存储true或者false
4.class类型 类类型
5.id类型 万能指针类型
6.nil 与NUll差不多
7.SEL 方法选择器
8.block 代码段

OC面向对象
类的声明
@inteface 类名 : NSObject
{
   //变量的声明写在这里
}
//方法的声明写在这里
@end

类的实现
@implementation 类名
//将方法的实现写在这里
@end

示例
@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
@end

@implementation Person

@end

注意点:
1.类必须要有声明和实现
2.类名的首字母要大写
3.变量必须要定义在@interface的大括号之中
4.变量名要用下划线开头

创建对象
对象的本质是一个C语言的结构体
语法：
类名 *对象名 = [类名 new];
Person *p1 = [Person new];

如何使用对象
访问对象属性
默认情况下，对象的属性是不允许被外界访问的，
如果允许对象属性可以被外界访问，那么在声明属性时要加一个@public
p1->_name = @"jack";//平时开发要使用->这种方式
p1->_age = 19;
(*p1)._name = @"jack";

OC的方法
示例
@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
方法的声明写这里
- (返回值)方法的名称;
- (返回值)方法的名称:(参数类型)形参名称;
- (返回值)方法的名称:(参数类型)形参名称1 :(参数类型)形参名称2;
@end

@implementation Person
方法的实现写这里
@end

@interface Person : NSObject
{
   @public
   NSString *_name;
   int _age;
}
- (void)run;//声名一个无返回值无参数的方法
- (void)eatWith:(NSString *)foodName;//注意，方法的名字叫eatWith:,如果方法只有一个入参，方法名最好
加上With，这样易读性更好,是一种规范
- (int)sum:(int)num1 :(int)num2;//注意，方法的名字叫sum: :
- (int)sum:(int)num1 and:(int)num2;//注意，方法的名字叫sum: and:,加上and更加易读
@end

@implementation Person
- (void)run
{
   NSLog(@"fsdafdasf");
}
- (void)eatWith:(NSString *)foodName
{
    NSLog(@"fsdafdasf%@",foodName);
}
- (int)sum:(int)num1 :(int)num2
{
    return num1 + num2;
}
- (int)sum:(int)num1 and:(int)num2
{
    return num1 + num2;
}
@end

如何调用方法
[对象名 方法]
Person *p1 = [Person new];
[p1 run];//调用无入参的函数
[p1 eatWith:@"iii"];//调用有一个入参数的函数
int sum = [p1 sum:10 :20];
int sum = [p1 sum:10 and:20];

类的加载
在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的
代码段区域，这个过程叫做类加载。
只有类在第一次被访问的时候，才会做类加载，一个类只会被加载一次。直到程序
结束之后才会被释放。

对象在内存中究竟是如何存储的
Person *p1 = [Person new];
Person *p1;//会在栈内存中申请一块指针变量的空间
[Person new];//真正在内存中创建对象的其实是这句代码
new做的事情
1.在堆空间中申请1块合适大小的空间
2.在这个空间中根据类的模板创建对象，类模板中定义了什么属性，就把这些
属性依次的声明在对象之中，对象中还有另外一个属性叫做isa，是一个指针，
它指向对象所属的类在代码段中的地址
3.初始化对象的属性
如果属性的类型是基本数据类型，那么就赋值为0
如果属性的类型是C语言的指针类型，那么就赋值为NULL
如果属性的类型是OC的类指针类型，那么就赋值为nil
4.返回对象的地址

注意
1.对象中只有属性而没有方法。
2.如何调用方法
[指针名 方法名];
先根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类，
然后再调用类里的方法。
3.为什么不把方法存储在对象之中
因为每一个对象的方法代码实现都是一模一样的，没必要为每一个对象都保存1个
方法，太浪费空间，所以只把方法存储在代码段就可以了。

nil
只能作为指针变量的值。
nil其实也等价也0，也是一个宏。
nil与C语言的NULL是一样的，两个值相等。
虽然使用NULL的地方可以使用nil，但不建议这样做。

分组导航标记
主要是用来给代码文件添加一种特殊的注释用的，要结合Xcode使用
#pragma mark 分组名
会在导航条对应的位置显示1个标题
#pragma mark -
会在导航条对应的位置显示1条水平分隔线
#pragma mark - 分组名
会在导航条对应的位置显示1条水平分隔线，再显示标题

OC中注意点
1.属性名一定要以下划线开头
2.属性不允许在声明的时候初始化或赋值
3.如果方法只有声明没有实现，在调用时会报错
```
2.今天开始学习oc语言了，学习完c语言确实能更有助于学习oc的一些知识，主要是内存方面的更好理解，这样可以更好的使用内存和优化性能

---
## 2019年3月13日
1. oc学习
```oc
多文件开发
.h头文件写类的声明
.m文件写类和方法的实现

类的本质
类是我们自定义的一个数据类型
什么是数据类型：
是在内存中开辟空间的一个模板
声明一个函数，参数可以传入一个对象
- (void)test:(Dog *)dog;
声明一个返回对象的函数
- （Dog *)test;

异常捕获
C语言的异常无法捕获
避免异常最常用的方法还是用逻辑判断
@try
{

}
@catch(NSException *ex)
{

}
@finally
{

}

类方法
对象方法声明使用的是-号
- (void)test;
类方法声明用+号
+ (void)test1;
类方法的调用
可以直接使用类名来调用方法
[类名 方法名]

类方法的特点
类方法不用在堆申请空间，所以节约空间
类方法不用再通过指针找到堆中的对象的isa指针，而是直接代码区调用，效率高
类方法不可以使用成员变量，但可以在类方法里创建对象，使用对象的方法和变量
在对象方法中可以直接调用类方法

什么时候可以将方法定义为类方法？
如果方法不需要直接访问属性，也不需要直接调用其它的对象方法，
那么就可以定义类方法，提高效率

类方法的规范
1.如果我们写一个类，那么就要求为这个类提供一个和类名同名的类方法，
且这个方法创建一个这个类的对象作为返回值。跟java的构造方法很像。
也可以给这个方法传入一些参数，给对象的变量赋值。
2.方法名要写成 类名WithXXX: 这是苹果的规范
如：NSString *str = [NSString string];

NSString一些常用方法
将C语言字符串转换为OC字符串
stringWithUTF8String

拼接一个字符串对象，使用变量或者其它数据拼接成OC字符串
stringWithFormat

得到字符串长度，这个是对象方法
length

得到字符串中指定下标的字符
characterAtIndex
这个函数返回的数据类型是unichar，因为有些国家的文字字符要占一个字节以上，
所以不能用char来表示，要输出unichar变量的值，要使用%C

判断两个字符串内容是否相同
判断两个字符串不能用==判断，这样判断是不准确的
isEqualToString

比较字符串的大小
返回值可以使用int来接收
compare

匿名对象
没有任何指针指向这个对象，那么这个对象就是匿名对象
匿名对象只能使用1次，每次创建的都是不同的对象
如：
[Pserson new];
使用匿名对象的变量和方法
[Pserson new]->_name=@"jack";
[[Person new] sayHi];

setter和getter方法
只要属性需要被外界访问，就要为这个属性封装getter和setter方法，即使不
需要逻辑验证
setter声明和实现方式与java一样
getter的方法名命名与java不同，oc直接使用去掉下划线的变量名即可。

对象与对象之间的关系
组合关系
一个类中的变量是其它类的对象

依赖关系
一个类的方法入参是另一个类的对象，属于高耦合

关联关系
一个类作为另一个类的属性，但他们不是组合关系，而是拥有的关系

```

---
## 2019年3月14日
1. oc学习
```oc
static关键字
oc中static不能修饰属性和方法，可以修饰方法中的局部变量
它存储在常量区，方法执行完成后不会被回收。跟c语言一样，
只有第一次调用这个方法的时候这个static变量才会被声明，
第二次及以后调用这个方法不会再次被声明。
如果方法的返回值是当前类的对象，那么方法的返回值就写instancetype

self关键字
和java中的this有一点点像。oc的selt可以用在类方法中，但java不行。
可以在对象方法和类方法中使用，self是一个指针，在对象方法中self指向当前对象，
但类方法中只能调用类方法，对象的方法也不可以调用类方法。
在类方法中指向当前类。
类方法中的self指向代码段当中的类。
开发规范，对象的属性要求以下划线开头，局部变量不以下划线开头
对象方法和类方法可以重名
self->_name;
[self test];

继承
继承之后，子类具有父类中所有的成员
如果有一个成员，他不是所有子类都拥有，那么这个成员不应该定义在父类之中。
一个类只能有一个父类
A类从B类继承，c类从B类继承，那么C类拥有AB两个类的成员
子类不能再定义与父类重名的属性
父类的类方法也会被子类继承
@interface Chinese : Person

@end

@implementation Chinese

@end

NSObject类
所有的类必须都得继承NSObject类，这样做是有原因的
当我们创建一个对象的时候，通常的写法是
[Persion new];
这个其实是调用了NSObject类的new方法，然后这个方法的返回值是Persion类的
指针，如果不继承NSObject类就没有new方法，创建不了对象
同时isa指针也是NSObject类中的一个属性

super关键字
1.可以用在类方法和对象方法中
2.在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法。
[super test]
3.在子类的类方法中，可以使用super关键字调用父类的类方法。
4.super只能用来调用父类对象或类方法，不能用来访问属性

访问修饰符
修饰类的属性，不可以修饰方法

@private
只能在本类的内部访问

@protected
只能在本类和本类的子类中访问，如果不指定访问修饰符，
默认使用这种

@package
只可以在当前框架中访问

@public
可以在任意的地方访问

子类可以继承父类的私有属性，只不过子类中无法直接访问
从父类继承过来的私有属性。但如果父类中有一个方法在为
属性赋值或者取值，那么子类可以调用这个方法间接的访问父类
的属性

私有方法
只写实现不写声名就可以了，oc中并没有修饰符来修饰方法

多态
里氏替换原则
子类可以替换父类的位置，并且程序的功能不受影响
Person *p1 = [Studen new];
```
2. 今天晚上我们同事聚餐了，波哥去别的组了，我们组也有三个人也要走了，最后波哥说以后我们富贵相见，感觉还是挺伤感的，
挺好的一个组，说解散就解散了，现在大家没有得到确定要留下消息的人都等着被裁员拿补偿，没什么心思干活了。昨天新的组长也
跟我进行了谈话，说希望我能留下，也不会把我裁掉，我不知道今年会怎么样，只是好好把活干好吧，再就是多学点技术，争取把ios学会，
再把c++也学习下，把android系统的底层也学习下，然后后端这块也能学下，把前后端打通。

---
## 2019年3月15日
1. oc学习
```oc
里式替换原则的作用
1.一个指针中不仅可以存储本类对象的地址，还可以存储子类对象的地址。
2.如果一个数组的元素类型是一个oc指针类型的，那么这个数组中可以存储本
类对象还有子类对象
3.如果一个数组的元素是NSObject指针类型，它可以存储任意类型的对象指针
4.当一个父类指针指向一个子类对象的时候，只能通过这个父类指针调用子类对象中
的父类成员，不能调用子类特有的方法

重写
直接在子类的.m文件重写父类的方法就可以了

多态
同一个行为，对于不同的事物具有完全不同的表现形式

当我们使用%@打印一个对象的时候，NSLog函数调用的是
传入对象的description方法。
```

---
## 2019年3月18日
1. oc学习
```oc
代码段存储类的那块空间是个什么类型
在代码段中存储类的步骤
1.先在代码段里创建一个class对象
2.把对象的信息存到class对象里面，如类名、方法和属性、isa指针，
isa指针指向他的父类的类对象

如何拿到存储在代码段中的类对象
注意:
声明Class指针的时候，不需要加*，因为在typedef的时候已经加*了
两种获取类对象的方式
1.调用类的类方法claas，就可以得到存储类的类对象地址
Class c1 = [Person class];
2.调用对象的对象方法class就可以得到这个对象所属的类的Class对象的地址
Person *p1 = [Person new];
Class c2 = [p1 class];

如何使用类对象
1.c1等价于Person类
调用类方法
[c1 test];
2.可以使用类对象来调用new方法
Person *p2 = [c1 new];
注意
使用类对象，只能调用类的类方法，不能调用类对象的方法

SEL
全称叫做selector，是选择器的意思
SEL是一个数据类型，所以要在内存中申请空间存储数据
SEL其实是一个类。SEL对象是用来存储一个方法的
类是以Class对象的形式存储在代码段中的
类的方法存储在类对象之中的一个数组里，数组里的每个元素都是一个SEL对象，
将类中的每个方法都封装一个SEL对象
如何拿到SEL对象
因为SEL是一个typedef类型，在自定义的时候已经加*了，所以声明SEL指针的
时候不用加*了
SEL s1 = @selector(test);

调用方法的本质
[p1 sayHi];
内部原理
1.先拿到存储sayHi方法的SEL对象
2.p1对象接收到这个SEL消息以后，就知道要调用方法
3.根据对象的isa指针找到存储类的类对象
4.找到这个类对象以后，在这个类对象中云搜寻是否有和传入的SEL数据相匹配的，
如果有就执行，没有再找父类，直到NSObject类

OC最重要的一个机制，消息机制就是这个调用方法的本质，
调用方法的本质其实就是为对象发送SEL消息

手动为对象发送SEL消息
1.先得到方法的SEL消息
Person *p1 = [Person new];
SEL s1 = @selector(sayHi);
2.将这个SEL消息发送给p1对象
[p1 performSelector:s1];
3.调用一个对象的方法有两种
[对象名 方法名];//常用
手机的为对象发送SEL消息

注意事项
1.如果方法有参数，那么方法名是要带上冒号的
2.还要传递参数
[p1 performSelector:s1 withObject:@"qqq"];
3.如果有多个参数
Params *ps = [Params new];
SEL s1 = @selector(testWith:);
[p1 performSelector:s1 withObject:ps];

点语法原理
p1.age = 18;
这句话本质并不是直接赋值给p1对象的_age属性，
点语法在编译器编译的时候，会将点语法转换为调用setter、getter代码
注意
1.在getter和setter中慎用点语法，因为有可能会造成无限递归
如
self.age;
2.点语法在编译器编译的时候，会转换为调用setter和getter方法的代码，
如果我们的setter方法和getter方法名不符合规范的话，那么点语法就只会出问题
3.如果属性没有封装getter和setter是无法使用点语法的

@property
声明一个类的时候总要为他的一些属性写上setter和getter方法，
我们可以使用@property来标识属性，这样会自动生成setter和getter方法
要写在.h文件里的属性下面
例如:
@interface Person : NSObject
{
   int _age;
}

@property int age;//这里不要加下划线

@end

使用注意
1.@property的类型和属性的类型一致因为这个决定着生成的getter和setter方法的返回值类型
2.@property的名称要去掉下划线，因为这个决定着生成的getter和setter方法的名字
3.@property只是生成getter和setter方法的声明，实现还要自己来写

@synthesize
作用:自动生成getter、setter方法的实现，所以应该写在类的实现之中,
但这样会新生成一个新的私有属性
语法:
@synthesize 属性名称;//注意不要加下划线
例如:
@implmentation Person

@synthesize age;//注意不要加下划线
@end

如果希望@synthesize不要自动生成私有属性的getter和setter方法，
而且是直接操作我们已经定义好的属性，就需要换一种写法
如下
@synthesize age = _age;

以上的@property和@synthesize是Xcode4.4以前的写法，从4.4以后
对@property做了一个增强
4.4以后只需要写一个@property编译器就会自动生成getter和setter方法,
如果需要在setter或getter做逻辑判断，直接重写这两个方法就可以，但
不能同时重写，会报错

id指针
是一个万能指针，可以指向任何oc的对象
id id1 = [Person new];
[id1 sayHi];//不用类型转换直接调用Persion里的方法

NSObject和id的异同
相同点:都是万能指针，都可以指向任意的oc对象
不同点:
通过NSObject指针去调用对象方法的时候，编译器会做编译检查。
通过id类型的指针去调用对象方法的时候，编译器直接通过。

注意点：
id指针只能调用对象方法，但不能使用点语法

instancetype
如果方法的返回值是instancetype,代表方法返回的是当前调用这个方法的对象。
使用建议
1.如果方法内部是创建当前类的对象，不要写死成[类名 new]
而是要用self代替类名，写成[self new]
2.如果方法返回值是当前类的对象，也不要写死成当前类名，而是要写instancetype

id和instancetype的区别
1.instancetyep只能作为方法返回值，不能在别的地方使用，
id可以声明指针变量，也可以作为参数，也可以作为返回值。
2.instacetype是一个有类型的，代表当前类的对象
id是一个无类型的指针，仅仅是一个地址，没有类型的指针。
```
2. 波哥今天就正式搬到那边了，中午也变成了我自己吃饭，还有一点点不太适应，哈哈，其实我是想去健身的，只是自己去
没意思

---
## 2019年3月19日
1. oc语言
```oc
构造方法
new方法的内部，其实是先调用alloc方法，再调用init方法
alloc方法是一个类方法，作用是创建调用方法的类的对象，并返回对象
init方法是一个对象方法，作用是初始化对象,为对象属性赋初始值，
这个init方法我们叫构造方法
虽然没有初始化的对象有时候也可以使用，但这样做是非常危险的。
Person *p1 = [Person new];
等价于
Person *p1 = [[Person alloc] init];

我们每次通过上面的方式创建对象时属性都是默认值，如果我们想不是属性为
默认值时，可以重写init方法
重写init方法的规范
1.必须先调用父类的init方法，然后将方法的返回值赋值给self
2.调用init方法初始化对象有可能失败，如果初始化失败，返回的就是nil
3.判断父类是否初始化成功，判断self的值是否为nil,如果不是则初始化成功
4.如果初始化成功，就初始化当前对象的属性
5.最后返回self
两种写法
- (instancetype)int
{
   self = [super init];
   if(self != nil)
   {
      self.name = @"jack";
   }
   return self;
}

- (instancetype)int
{
   if(self = [super init])
   {
      self.name = @"jack";
   }
   return self;
}
解惑
1.为什么要调用父类的init方法
因为父类的init方法会初始化父类的属性，如isa指针等，所以必须要保证当前
对象中的父类属性也被初始化
2.为什么要赋值给self
因为调用父类的init方法，会返回初始化成功的对象，实际上返回的就是当前对象。
但我们要判断是否初始化成功。

重写init方法的不足
每次创建出来的对象属性的值都是固定写死的
这时可以自定义构造方法
规范
1.自定义构造方法是返回值必须是initancetype
2.自定义构造方法的名称必须以initWith开头,因为self不能在initWith开头的方法外使用
3.方法的实现和init的要求一样

调用的时候要先调用alloc方法来创建对象，再调用初始化方法
如
Person *p = [[Person alloc] initWithName:@"小明" andAge:19];

内存管理
引用记数器
每一个对象都有一个属性，叫retainCount，引用记数器。类型是unsigned long占8个字节。
用来记录当前这个对象有多少个人在使用它。
如何操作引用计数器
1.为对象发送一条retain消息，引用计数就会加1
2.为对象发送一条release消息，对象的引用计数就会减1
3.为对象发送一条retainCount消息，就可以去查到引用计数器的值
当对象的计数器变为0的时候，对象就会被回收，
对象被回收的时候，就自动调用对象的dealloc方法

内存管理分类
MRC:手动引用计数，手动管理内存管理,要使用手动管理要先关闭ARC模式
需要程序员手动的发送retain和relase消息
ARC:自动引用计数，自动内存管理
系统自动的在合适的地方发送retain和relase消息

内存管理原则
1.有对象创建，要匹配一个release
2.retain的次数要和release的次数要匹配
3.谁用谁retain，谁不用谁release
4.只有在多一个人用的时候才retain，少一个人使用的时候才release
5.手动管理内存如果重写了dealloc方法时，要在dealloc方法的最后一行
调用父类的dealloc方法才行
如
[super dealloc];

野指针
在C语言中，定义一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，
指向一块随机空间，这个指针就叫野指针
在OC语言中，指针指向的对象已经被回收了，这样的指针叫野指针。

僵尸对象
一个已经被释放的对象，但是这个对象所占的空间还没有分配给别人，这样的
被叫做僵尸对象
打开僵尸对象检测功能，是极其损耗性能的，所以一般默认是关闭的
僵尸对象是无法被复活的

内存泄露
指的是一个对象没有被及时回收，一直驻留在内存中

单个对象的内存泄露
1.有对象的创建，没有对应的relase
2.retain的次数和relase的次数不匹配
3.在不适当的时候为指针赋值为nil
4.在方法中为传入的对象进行不适当的retain

如何保证单个对象可以被回收
1.有对象的创建，就必须要匹配一个relase
2.retain次数和release次数一定要匹配
3.只有在指针称为野指针的时候才赋值为nil
4.在方法中不要随意为传入的对象retain

当一个类的属性是一个oc对象的时候，setter方法写的方法，将
传进来的对象赋值给当前对象的属性，代表传入的对象多了一个人使用，
所以我们应该先为这个传入的对象发送一条retain消息，然后再赋值，
当当前对象销毁的时候，代表属性指向的对象少一个人使用，就应该在
dealloc中使用relase方法进行减少引用次数
代码写法
- (void)setCar:(Car *)car//注意，目前这个写法是有问题的，下面有改进方式
{
   _car = [car retain];
}
- (void)dealloc
{
  [_car release];
  [super dealloc];
}

当属性是一个OC对象的时候，setter照上面写还是有bug的，
当为这个属性多次赋值的时候，会产生内存泄露，
发生泄露的原因：
当为属性赋值的时候，代表旧对象少一个人用，新对象多一个
人用，应该先relase旧的对象，然后retain新的对象
改造后代码,其实这样写还是会有bug，如多次调用该方法入参car是同一个对象时
会出问题
- (void)setCar:(Car *)car
{
   [_car release];
   _car = [car retain];
}

解决上面问题的方案
当发现新旧是同一个对象的时候，什么都不用做，
只有新旧不是同一个对象的时候，才release旧的，retain新的
改进后代码
- (void)setCar:(Car *)car
{
   if(_car != car)
   {
      [_car release];
      _car = [car retain];
   }
}
- (void)dealloc
{
   [_car release];
   [super dealloc];
}
只有需要内存管理的oc对象属性才需要上面那种写法，普通的变量类型不用

@property生成setter和getter方法
它生成的setter方法的实现当中，无论是什么数据类型的，都是直接赋值的，
在MRC中如果属性是对象类型的话是不可以用的，需要自己重写

@propterty是可以带参数的
@property(参数1，参数2，参数3....)数据类型 名称;

@property的四组参数
a.与多线程相关的参数
atomic、nonatomic
b.与生成的setter方法的实现相关的参数
assign、retain
c.与生成只读、读写相关的参数
readonly、readwrite
d.是与生成的getter和setter方法名字相关的参数
getter、setter

与多线程相关的参数
atomic:默认值，这个时候生成的setter的代码就会被加上
线程安全锁，安全但效率低
nonatomic:这个时候生成的setter的代码就不会加上线程安全
锁，不安全但效率高，建议使用这种
```

---
## 2019年3月20日
1. 今天空域app开始测试了，有一个同事家里有事请长假回家了，还有一个同中要离职，他俩的bug目前都需要我来解，他俩的Bug
真是多啊，忙活一天，没办法学习oc了
2. 添加解析空域bean，修改json bean错误
3. 修改飞服师列表页时间错误
4. 修改编辑页执照为空错误
5. 修改首页开启围栏崩溃
6. 修改用户中心去掉计划入口
7. 修改我的机型列表为倒序排列
8. 修改无人机列表文本超出问题

---
## 2019年3月21日
1. 添加飞服师上传图片逻辑
2. 修改无人机列表型号错误
3. 解决资质认证界面解析错误问题
4. 修改添加飞服师成功后不返回列表页问题
5. 修改上传图片bug
6. 修改添加飞服师空类型判断
7. 修改多次点击提交按钮无反应
8. 修改编辑飞服师图片不显示问题
9. 修改证书不显示问题
10. 修改飞服师列表时间格式错误
11. 修改添加批件方案提示错误
12. 修改个人用户信息页显示方案错误
13. 修改日期控件默认展示开始日期
```oc
与生成的setter方法的实现相关的参数
assign:默认值，生成setter方法的实现就是直接赋值
retain:生成的setter方法的实现就是标准的MRC内存管理代码，先判断
新旧对象是否为同一个对象，如果不是release旧的
当属性类型是OC类型的时候，使用retain
当属性的类型不是OC类型的时候，使用assign
但是要注意，retain参数只是生成标准的setter方法为MRC内存管理代码，
不会在对象的delloc方法中生成relase代码，所以我们必须要手动的在dealloc中使用
release方法

与生成只读读写的封装
readwrite：默认值，代表同时生成getter和setter
readonly:只会生成getter

生成getter、setter方法名称相关的参数
默认情况下@property生成的getter和setter生成的是标准的名称，
但可以使用setter和getter入参来改生成方法的名称
一般情况下我们是不使用setter和getter来改名字的，但当属性是BOOL类型
的时候，可以修改这个getter的名字开头以is开头，提高代码可读性。

关于@class
当两个类互相包含的时候，会出现循环引用的问题，造成无限递归问题，导致
无法编译通过
解决方案
其中一边不要使用#import引入对方的头文件，而是使用@class来标注这个类，
这样就可以解决这个问题，还要在.m中使用#import引用对方法的头文件就可以有
代码提示了

@class与#import的区别
1.#import是将指定的文件内容拷贝到写指令的地方
2.@class不会拷贝内容，只是告诉编译器这是一个类

当两个对象相互引用的时候，A对象的属性是B,B对象的属性是A对象，这个时候
如果两边都使用retain那么就会发生内存泄露，谁都无法释放谁
如何解决
一端使用retain，另一端使用assign，使用assign的那一端在dealloc中不再需要
release了

自动释放池
存入到自动释放池中的对象，在自动释放池被销毁的时候，会自动调用存储在
自动释放池中的所有对象的release方法
这样就不再需要手动的去调用对象的release方法了
@autoreleasepool
{

}

```

---
## 2019年3月22日
1. 今天突然让写一个5g项目的招标文件，以前从来没接触过这个东西，刚看到跟天书一样，各种没见过的名词，
让往里写很内容感觉是根本不可能完成的事。不过还好，在网上找了一堆东西拼了上去，只是不知道能不能合格，
实在是不会写这个东西，应该找更专业的人来写啊，毕竟这个是很重要的东西。下周一周的时间都要用来写这个，
希望能赶紧写完吧。
2. 听说有的部门已经开始996了，我们这基本上算是995吧，不知道什么时候也要变成996。我们的工位也换了，
搬到了16层，我的位置还行，比想象中好点吧，但没有18层那么好，换了环境感觉像是换了一份工作一样。身边的
同事各种请假，周四、周五和周末两天一连上真爽啊。不知道他们是去面试了还是怎样。

---
## 2019年3月25日
1. 状态不好，看了一点oc视频，不过知识基本都会

---
## 2019年3月26日
1. oc学习
```oc
分类
在创建一个类文件的时候，会有一个File Type的选项，这里面要选Category类型，
才可以创建分类的文件
1.将一个类分为多个模块，其实就是给一个类添加新的方法，这样可以
在不改变以前的类文件的情况下做到
2.如何为一个类添加分类
跟创建普通的类一样，只是多一个分类名在类名的后面，用括号包含.
分类并不是创建一个新类，而是对已有的类添加一个分类。一个类可以
有多个分类，所以每个分类要有自己的名字。
3.会生成一个.h和一个.m的模块
模块文件名是:
本类名+分类名.h
本类名+分类名.m
4.添加的分类也分为声明和实现
@interface 本类名 (分类名)

@end

@implementation Student (itcase)

@end
5.分类的使用
如果要访问分类中定义的成员或方法，就要把分类的头文件引进来

使用分类要注意的几个地方
1.分类只能增加方法，不能增加属性
2.在分类之中可以写@property，但是不会自动生成私有属性，也不会
自动生成getter和setter的实现，只会生成getter和setter的声明。
3.在分类的方法实现中不可以直接访问分类的私有属性，但可以调用
本类的getter和setter方法来访问属性。
4.当分类中有和本类中同名的方法的时候，优先调用分类的方法，哪怕
没有引入分类的头文件。如果多个分类中有相同的方法，优先调用最后
编译的分类。

非正式协议
非正式协议是给系统自带的类定义分类

ARC机制和垃圾回收机制的区别
GC：
程序运行的期间，垃圾回收器不断的扫描堆区进行垃圾回收。
ARC
是在程序编译的时候，就把释放对象的语句写的代码中了。

类的一类构造方法初始化属性时要注意的点
下面是错误代码
- (instancetype)initWithCar:(Car *)car
{
   if(sele = [super init])
   {
      _car = car;//错误写法
   }
   return self;
}

- (void)dealloc
{
   [_car release];
   [super dealloc];
}
当使用_car = car;赋值的时候，并没有调用对象的retain方法，这样
对象的引用数不会加1，当外部释放对象引用的时候，会造成僵尸对象，
car方法已经被释放掉了
应改为
- (instancetype)initWithCar:(Car *)car
{
   if(sele = [super init])
   {
      self._car = car;//这里改成这种写法
   }
   return self;
}

- (void)dealloc
{
   [_car release];
   [super dealloc];
}
当我们使用self._car = car;进行赋值的时候，
self.car会自动调用当前类的setter方法，这样
setter方法使用@propety时，会自动调用car对象的
retain方法，进行引用数加一，这时就不会出错了。

延展(Extension)
在创建一个类文件的时候，会有一个File Type的选项，这里面要选Extension类型
延展是一个特殊的分类
特殊之处:
a.延展没有分类名字
b.只有声明没有实现，只有一个.h文件，并且和本类共享一个实现
c.延展当中可以加属性，@property会自动生成getter和setter的声明和实现
延展语法
@interface 本类名 ()

@end

什么时候使用延展
当我们想要为类定义私有成员的时候，就可以使用延展，将延展定义在类的实现
文件中。
如果想要为类写一个私有属性，虽然我们可以定义在@implementation之中，但
不要这么写，因为不规范。我们需要写一个延展，将私有属性定义在延展中。
如果要为类写一个私有方法，建议将声明写在延展中，实现写在本类的实现中，
这样可以提高代码的可读性。
如果想要为类写一个私有的@property属性，就直接写在延展里就可以了。

block
block是一个数据类型。是用来存储一段代码的。这段代码可以有参数，
可以有返回值。但并不是任意一段代码都可以存进去的，而是有限定的。
语法格式
返回值类型 (^block变量的名称)(参数列表);
void (^myBlock1)();
int (^myBlock2)();
int (^myBlock3)(int num1,int num2);

初始化block变量
格式：
^返回值类型(参数列表){
     代码段;
};
^void(){
   NSLog(@"opop");
};
可以将这段代码使用赋值符号存储到无返回值无参数要求的block变量中。
两种赋值方式
void (^myBlock1)();
myBlock1 = ^void(){
    NSLog(@"ljkljklj");
};

void (^myBlock1)() = ^void(){
    NSLog(@"ljkljklj");
};

有返回值的代码段
int (^myBlock2)() = ^int(){
    int num = 10 + 20;
    return num;
};

既有参数又有返回值的
int (^myBlock3)(int num1,int num2) = ^int(int num1,int num2){
     return num1 + num2;
};

如何执行代码段变量中的代码
myBlock1();
int i = myBlock(10,20);

关于block简写
1.如果我们写的代码段没有返回值,void可以不写
void (^myBlock1)() = ^(){
   NSLog(@"fdfsf");
};
2.如果代码段没有参数，小括号也可以不写
void (^myBlock1)() = ^{
   NSLog(@"fdfsf");
};
int (^myBlock1)() = ^int{
   NSLog(@"fdfsf");
   return 1;
};
3.声明block变量的时候，如果有指定参数，可以只写参数类型而
不写参数名称
int (^myBlock3)(int,int) = ^int(int num1,int num2){
     return num1 + num2;
};
4.无论代码段是否有返回值，在写代码的时候，可以不写返回值类型。
如果在写代码段的时候，省略的返回值，这个时候系统会自动确定返回值
类型。
但建议不要简写。
int (^myBlock3)(int,int) = ^(int num1,int num2){
     return num1 + num2;
};

使用typedef简化block定义
typedef void (^NewType)();
NewType block1;
NewType block2;
typedef int (^NewType2)(int num1,int num2);
NewType2 t1 = ^int(int num1,int num2){
   return 1;
};
```

---
## 2019年3月27日
1. oc学习
```oc 
关于block块访问外部变量的问题
1.在block代码块的内部可以取定义在外部的变量的值，定义在外部的局部变量和全局变量。
2.在block代码块的内部可以修改全局变量的值，但不能修改定义在外部的局部变量的值
3.如果你希望我们定义的局部变量可以允许在block代码的内部去修改，那么就为这个局部变量前
面加一个__block的修饰符。

block作为函数的参数
两种写法
void test(void (^block1)())
{
    block1();
}

tyepdef void (^NewType)();
void test(void (NewType block1)
{
    block1();
}

如何调用test方法
两种方式
NewType type = ^{
   NSLog(@"fsdfdsaf");
};
test(type);

test(^{
   NSLog(@"fsdfdsaf");
});

block也可以做为函数的返回值

协议(Protocol)
作用
1.专门用来声明一大堆方法的
2.只要某个类遵守这个协议，就相当于拥有这个协议的所有方法。
3.协议中只能声明方法，不能定义属性，也没有方法的实现
4.一个类只能有一个父类，但可以有多个协议
5.类的名称可以和协议的名称相同
语法
@interface 类名 : 父类名 <协议名>

@end

@interface Dog : NSObject <MyProtocol>

@end

@interface Dog : NSObject <MyProtocol,YouProtocol>

@end

修饰协议的两个修饰符
@required
在协议中，如果方法是被@required修饰，那么遵守这个协议的类必须要实现这个方法，
否则编译器会发出警告，默认是@required
@optional
如果方法是被@optional修饰,那么遵守这个协议的类可以实现这个方法，也可以不实现这个方法，
不实现编译器也不会报警告

协议可以从另外一个协议继续
子协议不仅有自己的方法声明，还包含父协议的方法声明
语法
@protocol SportProtolcol <FProtocol>

@end

```
2. 今天凌晨，我最喜欢的游戏之一要出新内容了，好激动呀，不过由于明天要上班所以就不能第一时间玩上了
3. 上午学习了一下关于gradle方面的知识

---
## 2019年3月28日
1. oc学习
```oc
协议类型的限制
声明一个指针，可以指向任意对象，但要求指向的对象要遵守指定的协议。
NSObject<协议名称> *指针名;
这个时候，这个指针可以指向遵守了指定协议的任意对象，否则会报一个警告。
如果一个指针有多个协议，那么指针指向的对象也要同时遵守多个协议。

Foundation框架常用类
NSString
字符串的内容是不可变的，如果给字符串指针变量重新赋值的时候，
其实是重新指向了一个新的字符串常量。
当两个字符串指针变量所指向的字符串内容一样时，其实两个指针指向
的地址是一样的。
存储在常量区的字符串是不会被回收的。
//这种方式声明字符串，字符串的值是存在常量区中的
NSString *str1 = @"jack";
//这种方式声明字符串，字符串的值是存在堆中的
NSString *str2 = [NSString new];
//将字符串内容写到文件中
writeToFile
参数1:写入到的文件路径
参数2:YSE，先将内容写到一个临时文件，如果写入成功再把文件搬到指定的目录。
NO,直接将内容写入到指定文件，这个不安全，但是效率高，一般使用此种方法。
参数3:指定写入的编码
参数4:二级指针，要传递一个NSError指针的地址。如果写入成功，这个指针的值
是一个nil，如果写入失败，指针指向一个对象，描述了发生错误的信息，
这个对象的localizedDescription方法可以得到发生错误的信息。
返回值是BOOL，代表是否写入成功。

从磁盘上的文件读取文件内容
+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:
(NSStringEncoding)enc error:(NSError **)error;

NSURL
作用：
既可以读写本地文件，也可以读写网页文件、ftp服务器上的文件
不同的类型的URL地址的写法
1.本地磁盘文件：file:///User/aa/1.txt
2.网页地址:http://www.itcase.cn/index.html
3.ftp文件的地址:ftp://server.itcase.con/1.txt
将不同类型地址封装在NSURL对象之中
NSURL *u1 = [NSURL URLWithString:@"http://www.itcase.cn/index.html"];
//读取文件内容
NSString *str = [NSString stringWithContentsOfURL:u1 
encoding:NSUTF8StringEncoding error:nil];
//写入文件内容
NSString *str @"dfasf";
BOOL res = [str writeToURL:u1 atomically:NO encoding:NSUTF8StringEncoding error:nil];

判断字符串是否以指定的字符串开头
- (BOOL)hasPrefix:(NSString *)str;
判断字符串是否以指定字符串结尾
hasSuffix

在字符串中搜索子串
返回值NSRange是一个结构体，里面有两个属性。
location:代表子串在主串中的第一次出现的下标，没有找到此值为NSUInteger的最大值，
也等于NSNotFound
length代表子串在主串中匹配的长度，如果没有匹配到此值是0
-(NSRange)rangeOfString

截取字符串
从指定的下标处一直截取到最后
substringFromIndex
NSString *newstr = [str substringFromIndex:3]
从第0个开始截取指定的个数
substringToIndex
截取自定义的范围
substringWithRange

字符串替换
//这个方法会替换字符串里所有相同的字符
stringByReplacingOccurrencesOfString

NSMutableString
使字符串具备可变性，可以更改字符串
不可以使用下面的方式进行初始化
NSMutableString *str = @"fdsf";

NSArray
1.是Foundation框架的一个类，具备数组的功能
2.只能存储OC对象
3.长度固定，一旦NSArray创建完成，长度不可改变，无法新增和删除元素
4.元素的类型是id类型
5.将元素写完以后，最后要写一个nil，表示数组结束
6.如果数组的中间元素有一个nil，后面的元素都会失效
常用的初始化方法
第一种方式
arrayWithObjects
第二种方式，简要的方式，这种方式不需要在最后加nil
NSArray *arr = @[@"jack",@"rose"];
当NSArray里存的元素类型不一致时，可以使用id来遍历
```

---
## 2019年3月29日
1. oc学习
```oc
NSMutableArray
是NSArray的子类，但他是可以新增元素和删除元素的，是一个可变的数组。
注意点
NSMutableArray不可以使用下面的方法初始化
NSMutableArray *arr = @[@"dfsa",@"fdf"];

NSNumber
OC定义的封装基本类型值的一个对象，主要是为了可以把int值存入到
NSArray里使用。
NSArray *arr = @[@10,@20,@30];
上面的代码，@10代表一个NSNumber对象，这个对象包装的是整形的10。
也可以把变量的int赋值给NSNumber
int num = 10;
NSNumber *n1 = @(num);

NSDictionary
NSMutableDictionary
这们是数组，但是以键值对的形式存储数据的。
键只能是遵守了NSCoping协议

NSDictionary下面这种初始化方法，是值在前，键在后
NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@"jack",@"name",@"北京市",@"address,nil"];
简要创建方式，这种是键在前，值在后
NSDictionary *dict = @{@"name":@"rose",@"age":@"18"};
遍历的话要使用for in的方式来遍历
item键，通过item来取值
for(id item in dict)
{
  dict[item];
}
还可以使用blcok的方式遍历
[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key,id _Nonnull obj,  
BOOL * _Noonull stop){
   
}];

NSMutableDictionary不能使用下面的方式初始化，要使用
dictionartWithObjectsAndKeys方法初始化
NSMutableDictionary *dict = @{@"":@"",@"":@""};
新增键值对
调用setObject方法，这个是值在前键在后
也可以将字典数组持久化
writeToFile
dictionaryWithContentsOfFile

在MRC的模式下，将一个对象存储到集合中，会为这个对象的引用计数器+1。
当集合销毁的时候，就会向存储在集合中的所有对象发送一个release消息。
在ARC的模式下，集合的元素是一个强类型的指针。

NSFileManager是Foundation框架提供的一个类，
可以用这个类操作磁盘上的文件、文件夹，对它们进行删除、移动、复制、拷贝、创建

CGPoint
是一个结构体，是用来表示ios控件在界面上的坐标。
快速创建一个CGPoint对象
CGPoint p1 = CGPointMake(20,30);

CGSize
用来表示一个控件的大小，宽度和高度。

CGRect和NSRect
这个结构的作用是用来存储一个控件的位置和大小。

NSValue
这个类的作用是用来包装一些无法存储到NSArray数组中的结构体的。

NSDate
时间日期的处理
```
2. 今天是3月份的最后一天，oc基础也差不多快要学完了，下周开始准备做ios的小项目，熟悉下生命周期和一些控件。
3. 早上刚来，我们组的几个同事都被叫出去聊了要被裁员的事情，最后组里剩不下几个人，感觉还是挺凄凉的。看来还是要不断的提高自己
的技术水平，这样就不怕在经济寒冬的时候被裁员而找不到工作。

---
## 2019年4月1日
1. 今天是宝宝的生日，时间过的真快，一年的时候转眼就过去了，希望五年后会有新的变化，越过越好。
2. oc学习，今天就把oc全部的视频课程看完了，下一步要开始真正的ios开发了，学习ios方面的知识。
```oc
字符串的copy
无论在MRC还是ARC，如果属性的类型是NSString，@property参数要使用copy。
copy是一个方法，定义在NSObject类之中，作用是拷贝对象。
NSSttring使用copy没有产生新对象，而是直接将对象本身的地址返回，这种
拷贝我们叫浅拷贝。
NSMutableString调用copy方法，会产生一个新的对象，这种叫深拷贝。但
返回的是一个不可变的对象(NSString对象)。
mutableCopy，是定义在NSObject中的方法，是深拷贝，返回的是一个可变的
字符串对象。
字符串对象拷贝的引用计数器问题
1.若字符串对象存储在常量区中，存储在常量区的数据是不允许被回收的，
所以存储在常量区的字符串对象的引用计数器是一个超大数，并且retain
和release无效。
2.若字符串存储在堆区，这个字符串对象和普通的对象一样的，引用计数器
默认是1.
3.字符串对象如果是浅拷贝，会将对象的引用计数器加1
字符串对象如果是深拷贝，原来的对象的引用计数器不变，新拷贝出来的对象
的引用计数器为1.

对象拷贝
1.copy方法是内部调用了另一个叫copyWithZone方法，
这个方法是定义在NSCoping协议中的，如果我们自己定义的类没有遵守NSCoping
协议，调用copy方法就会报错
2.自己创建的类要遵守NSCoping协议，还要重写copyWithZone方法
//深拷贝实现方法
- (id)copyWithZone:(NSZone *)zone
{
  Person *p1 = [Person new];
  p1.name = _name;
  return p1;
}
//浅拷贝
- (id)copyWithZone:(NSZone *)zone
{
  
  return self;
}
```
---
## 2019年4月2日
1. 学了一天的ios控件，包括看书和看视频，有点走出了舒适区的感觉，什么都不会，从头摸索学习新知识，是会感觉会不舒服，
但这样才能使自己进步，相信会越来越适应，克服这种不适感。入门的话看书的效率确实低一些，有些书写的并不是很明白，看视频
人家一讲就明白了。

---
## 2019年4月8日
1. 回老家休息了四天，姑娘一岁了，感觉比过年看到她时聪明不少，现在知道主要要吃的和她不喜欢做的事会哭了。感觉每天除了看孩子
就是睡觉，时间过的很快，好像只在家待了一天就回来了。
2. 修改消息页UI
3. 添加无人机上传图片功能
4. 添加提交无人机数据判断逻辑
5. 修改无网络时提交图片接口报错
6. 修改软键盘类型错误问题

---
## 2019年4月9日
1. 通过视频学习了ios的界面开发，使用tableView开发简单的列表样式。自己手动跟着视频课程做了一次，还需要多多复习啊，刚开始做很生疏，
做的很慢，后面多做做应该就好了。学习了三种界面开发的方式。

---
## 2019年4月10日
1. 今天学习ios学的有点灰心，可能是进步不明显再加上热情期过了吧，再就是有一点动摇的原因是感觉出去找工作学这个似乎用不太上，
应该把数据结构或者安卓啥的东西再精进一下。不过我当初学ios是为了学flutter的时候可以更好的理解两端融合，还有就是做ios的同事
如果离职了如果有ios我可以做。我还是要坚持学，不然前期学的c和oc都白费了，继续努力坚持。
2. 今天确定小宝宝这个月不过来北京了，因为她去到人多的地方就会不适应，会哭的很厉害，一冬天没有出门，冷不丁一出门会害怕。最近天暖和了，
多带她出去转转，看看秋天能不能来吧。

